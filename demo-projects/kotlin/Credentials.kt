// Auto-generated by credential-code
// DO NOT EDIT - This file will be overwritten

package com.example.credentials

import javax.crypto.Cipher
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.SecretKeySpec

enum class CredentialKey {
    API_KEY,
    AWS_SECRET_KEY,
    DATABASE_URL,
    JWT_SECRET,
    STRIPE_KEY,
}

object Credentials {
    private data class EncryptedData(
        val data: ByteArray,
        val nonce: ByteArray,
        val tag: ByteArray
    )
    
    // Encrypted credential data as byte arrays
    private val encryptedData = mapOf(
        CredentialKey.API_KEY to EncryptedData(
            data = byteArrayOf(
                0x33, -33, -4, 0x10, -20, 0x78, 0x02, -112,
                -81, -34, -18, -18, 0x5D, -28, -21, 0x26,
                -71, -68, -115, -85, -94, -9, 0x40, -113
            ),
            nonce = byteArrayOf(
                0x0A, -31, 0x3D, 0x34, 0x79, 0x61, 0x38, 0x4B,
                0x26, -47, 0x57, 0x54
            ),
            tag = byteArrayOf(
                0x20, 0x7F, -13, -65, 0x63, 0x0D, 0x5A, 0x27,
                0x3D, -120, 0x32, 0x50, 0x30, -92, -37, 0x2C
            )
        ),
        CredentialKey.AWS_SECRET_KEY to EncryptedData(
            data = byteArrayOf(
                -85, 0x30, -79, 0x39, -33, 0x4F, 0x58, 0x71,
                -57, -45, 0x69, -80, 0x4A, -51, 0x79, 0x50,
                0x36, 0x42, -95, -41, -108, 0x49, -9, -106,
                0x79, -23, 0x15, -39, 0x04, 0x06, -126, -17
            ),
            nonce = byteArrayOf(
                -91, -102, 0x10, -37, 0x59, -68, -54, 0x32,
                0x16, 0x54, 0x6C, -127
            ),
            tag = byteArrayOf(
                0x05, -73, -23, -80, 0x49, 0x18, 0x40, 0x16,
                -96, 0x59, -4, 0x1D, -29, -83, -94, -63
            )
        ),
        CredentialKey.DATABASE_URL to EncryptedData(
            data = byteArrayOf(
                -99, 0x34, 0x4A, 0x46, -3, -40, 0x70, 0x6F,
                0x63, 0x26, -61, 0x20, -124, 0x09, -71, -86,
                -83, -52, -25, -37, 0x14, 0x15, 0x35, 0x4B,
                -92, 0x2F, 0x28, -49, 0x08, 0x40, -119, -54,
                -90, -5, 0x14, 0x35, -46, 0x04, -92, 0x12,
                -29, -28, -55, -47
            ),
            nonce = byteArrayOf(
                0x53, -36, -44, 0x30, 0x3B, 0x05, 0x06, 0x6A,
                -83, 0x26, -41, -74
            ),
            tag = byteArrayOf(
                0x09, -80, 0x0C, 0x41, 0x6A, -36, -93, 0x0C,
                0x54, 0x1F, 0x0F, 0x1B, 0x50, -87, -17, 0x77
            )
        ),
        CredentialKey.JWT_SECRET to EncryptedData(
            data = byteArrayOf(
                0x27, 0x71, -107, -71, 0x71, 0x74, -107, -10,
                -119, 0x0A, 0x4C, 0x4C, -6, -24, -124, 0x02,
                0x55, 0x5F, 0x2D, -97, -59, 0x33, -18, 0x5C,
                0x75, -74, -27, 0x5E, -38
            ),
            nonce = byteArrayOf(
                0x2B, 0x06, 0x39, 0x33, -42, -79, -81, 0x20,
                0x51, -25, 0x44, 0x3E
            ),
            tag = byteArrayOf(
                0x44, 0x27, 0x30, 0x21, -37, -118, 0x34, -8,
                -83, 0x04, -57, -48, -79, -45, -112, -75
            )
        ),
        CredentialKey.STRIPE_KEY to EncryptedData(
            data = byteArrayOf(
                -72, -118, -128, -110, -105, -61, -73, 0x4B,
                -103, -90, -103, -117, 0x1A, 0x16, -28, 0x65,
                0x16, 0x62, -125, -69, 0x2C, -41, 0x3A, 0x6A,
                -71, -73, -40
            ),
            nonce = byteArrayOf(
                0x27, -30, 0x24, 0x4E, -103, 0x29, 0x53, 0x49,
                0x01, 0x19, -91, -7
            ),
            tag = byteArrayOf(
                0x17, -22, 0x5A, 0x73, -23, -127, -67, 0x25,
                -50, 0x4E, 0x23, -21, 0x20, -81, 0x29, -64
            )
        ),
    )

    // Runtime decryption key (obfuscated)
    private val keyComponents = arrayOf(
        byteArrayOf(0x70, -97, -19, -18),
        byteArrayOf(-61, -56, -100, 0x09),
        byteArrayOf(-2, 0x5D, -72, 0x2C),
        byteArrayOf(0x24, 0x45, -34, -1),
        byteArrayOf(0x78, 0x0C, -88, 0x53),
        byteArrayOf(0x34, 0x0D, 0x57, 0x0F),
        byteArrayOf(-114, 0x39, -75, 0x45),
        byteArrayOf(0x52, -127, 0x61, -68),
    )

    @JvmStatic
    fun decrypt(key: CredentialKey): String? {
        val encrypted = encryptedData[key] ?: return null
        
        return try {
            // Reconstruct the decryption key
            val keyData = keyComponents.flatMap { it.toList() }.toByteArray()
            val secretKey = SecretKeySpec(keyData, "AES")
            
            // Setup cipher for AES-GCM
            val cipher = Cipher.getInstance("AES/GCM/NoPadding")
            val gcmSpec = GCMParameterSpec(128, encrypted.nonce)
            cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec)
            
            // Combine ciphertext and tag for decryption
            val cipherTextWithTag = encrypted.data + encrypted.tag
            val decrypted = cipher.doFinal(cipherTextWithTag)
            
            String(decrypted, Charsets.UTF_8)
        } catch (e: Exception) {
            null
        }
    }
    
    // Optional: Decrypt with caching
    private val cache = mutableMapOf<CredentialKey, String>()
    
    @JvmStatic
    fun decryptCached(key: CredentialKey): String? {
        cache[key]?.let { return it }
        
        val decrypted = decrypt(key) ?: return null
        cache[key] = decrypted
        return decrypted
    }
    
    // Clear cache when needed
    @JvmStatic
    fun clearCache() {
        cache.clear()
    }
}