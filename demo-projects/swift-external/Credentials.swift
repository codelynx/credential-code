// Auto-generated by credential-code (External Key Source Mode)
// DO NOT EDIT - This file will be overwritten

import Foundation
import CryptoKit

public enum CredentialKey: String, CaseIterable {
    case API_KEY = "API_KEY"
    case AWS_SECRET_KEY = "AWS_SECRET_KEY"
    case DATABASE_URL = "DATABASE_URL"
    case JWT_SECRET = "JWT_SECRET"
    case STRIPE_KEY = "STRIPE_KEY"
}

public struct Credentials {
    // Encrypted credential data as byte arrays
    private static let encryptedData: [CredentialKey: (data: [UInt8], nonce: [UInt8], tag: [UInt8])] = [
        .API_KEY: (
            data: [
                0xEE, 0x2C, 0x52, 0xBD, 0xB0, 0xA9, 0x01, 0x00,
                0xE0, 0xD1, 0xCA, 0x6D, 0x58, 0x1C, 0x4E, 0x92,
                0x4B, 0xDF, 0xA3, 0x95, 0x6C, 0xC6, 0xB7, 0xAD
            ],
            nonce: [
                0x1E, 0x00, 0x89, 0x7B, 0x66, 0x24, 0xFA, 0xB0,
                0xEE, 0x4F, 0x35, 0xB0
            ],
            tag: [
                0x25, 0x45, 0x09, 0xB7, 0x4F, 0xE6, 0x6A, 0x09,
                0x5B, 0x99, 0x8A, 0x06, 0xC5, 0x7A, 0x51, 0x9A
            ]
        ),
        .AWS_SECRET_KEY: (
            data: [
                0x6E, 0x82, 0x43, 0xAE, 0x91, 0x17, 0xA8, 0xC2,
                0x88, 0x09, 0x16, 0xE4, 0xCA, 0x9E, 0xDA, 0x85,
                0x66, 0x4E, 0x89, 0x4B, 0x57, 0xD8, 0x42, 0xA5,
                0x12, 0xDE, 0x1E, 0x6D, 0x69, 0xF7, 0x37, 0x80
            ],
            nonce: [
                0x00, 0x0B, 0xF2, 0x87, 0x4E, 0x12, 0x27, 0xC0,
                0xE8, 0xA3, 0xEB, 0x99
            ],
            tag: [
                0x97, 0x2B, 0x57, 0xD6, 0x73, 0x37, 0x41, 0x17,
                0xFE, 0xD1, 0x1F, 0x18, 0xD9, 0x57, 0x98, 0x46
            ]
        ),
        .DATABASE_URL: (
            data: [
                0x43, 0x96, 0x14, 0x0E, 0xBF, 0xFD, 0xBF, 0x60,
                0xFD, 0x47, 0xA6, 0x46, 0xF3, 0xC4, 0xD4, 0x30,
                0x64, 0x06, 0x9D, 0xD8, 0xD5, 0x98, 0x1D, 0xBA,
                0x62, 0xEB, 0xDE, 0xB8, 0xE4, 0xF1, 0xEF, 0x67,
                0xA4, 0x8A, 0x01, 0x54, 0x27, 0x95, 0x2D, 0x59,
                0xF2, 0xAE, 0x19, 0xC5
            ],
            nonce: [
                0xFA, 0x2E, 0xCD, 0xFA, 0xD0, 0xC1, 0x00, 0x7B,
                0x25, 0x16, 0x44, 0x6F
            ],
            tag: [
                0xAF, 0xD6, 0xA9, 0x55, 0x2C, 0xA7, 0x0C, 0x8C,
                0x7D, 0x87, 0x67, 0xA5, 0x9B, 0x68, 0x4B, 0xB4
            ]
        ),
        .JWT_SECRET: (
            data: [
                0x89, 0xFE, 0xDC, 0xDD, 0x26, 0xDC, 0x9A, 0x67,
                0x76, 0x34, 0x38, 0x10, 0x25, 0x99, 0x33, 0x74,
                0xCF, 0xD4, 0x1E, 0xCA, 0xC1, 0x3C, 0x2A, 0x37,
                0xE6, 0x7C, 0xF6, 0xA7, 0x2E
            ],
            nonce: [
                0x43, 0xAB, 0xE7, 0x94, 0xEF, 0x58, 0xA0, 0xD4,
                0xC6, 0x6E, 0x23, 0x58
            ],
            tag: [
                0x64, 0xE5, 0x8B, 0xEC, 0xAB, 0x20, 0x53, 0x02,
                0xE5, 0x96, 0x17, 0x7A, 0x69, 0xD2, 0x4E, 0x19
            ]
        ),
        .STRIPE_KEY: (
            data: [
                0x4D, 0x18, 0x1D, 0x99, 0x27, 0x02, 0x80, 0xD9,
                0xFD, 0x76, 0xDB, 0xBF, 0x23, 0x25, 0x55, 0x59,
                0x46, 0xE5, 0x0D, 0x17, 0xA5, 0x10, 0xE8, 0xFB,
                0x85, 0x93, 0xF0
            ],
            nonce: [
                0x29, 0x7B, 0xD0, 0x89, 0xB0, 0xE9, 0xFE, 0x2A,
                0x2E, 0xE9, 0x46, 0xAB
            ],
            tag: [
                0x51, 0x4F, 0xF4, 0xB2, 0x0E, 0x46, 0xE6, 0x40,
                0x51, 0x18, 0x13, 0x4C, 0x97, 0x3F, 0x42, 0x19
            ]
        ),
    ]

    // Get encryption key from CredentialKeyProvider
    private static func getEncryptionKey() throws -> SymmetricKey {
        // When using external key source, CredentialKeyProvider should be included in compilation
        // This will cause a compile error if CredentialKeyProvider is not available,
        // which is the intended behavior
        return SymmetricKey(data: CredentialKeyProvider.key)
    }
    
    // Decrypt a credential at runtime
    public static func get(_ key: CredentialKey) throws -> String {
        let encryptionKey = try getEncryptionKey()
        
        guard let encrypted = encryptedData[key] else {
            throw CredentialError.credentialNotFound
        }
        
        // Reconstruct the sealed box
        let nonce = try AES.GCM.Nonce(data: Data(encrypted.nonce))
        let sealedBox = try AES.GCM.SealedBox(
            nonce: nonce,
            ciphertext: Data(encrypted.data),
            tag: Data(encrypted.tag)
        )
        
        // Decrypt
        let decryptedData = try AES.GCM.open(sealedBox, using: encryptionKey)
        
        guard let value = String(data: decryptedData, encoding: .utf8) else {
            throw CredentialError.decryptionFailed
        }
        
        return value
    }
    
    // Convenience subscript access
    public static subscript(key: CredentialKey) -> String? {
        try? get(key)
    }
}

// Error cases
enum CredentialError: Error {
    case credentialNotFound
    case invalidEncryptedData
    case decryptionFailed
}