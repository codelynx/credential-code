import Foundation
import CryptoKit

struct SwiftCodeGenerator: CodeGenerator {
    let language = "swift"
    let defaultFileName = "Generated/Credentials.swift"
    
    func generate(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Use the provided encryption key as the runtime key
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            // Convert plain text to data
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            // Encrypt with runtime key
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate Swift code
        return generateSwiftCode(
            credentials: encryptedCredentials,
            runtimeKey: encryptionKey
        )
    }
    
    private func generateSwiftCode(credentials: [EncryptedCredential], runtimeKey: Data) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        import Foundation
        import CryptoKit
        
        public enum CredentialKey: String, CaseIterable {
        """
        
        // Add credential keys
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    case \(credential.key) = \"\(credential.key)\""
        }
        
        code += "\n}\n\n"
        
        // Add Credentials struct
        code += """
        public struct Credentials {
            // Encrypted credential data as byte arrays
            private static let encryptedData: [CredentialKey: (data: [UInt8], nonce: [UInt8], tag: [UInt8])] = [
        """
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        .\(credential.key): ("
            code += "\n            data: \(formatByteArray(credential.encryptedData)),"
            code += "\n            nonce: \(formatByteArray(credential.nonce)),"
            code += "\n            tag: \(formatByteArray(credential.tag))"
            code += "\n        ),"
        }
        
        code += "\n    ]\n\n"
        
        // Add obfuscated key
        let keyComponents = splitIntoComponents(runtimeKey, componentSize: 4)
        code += "    // Runtime decryption key (obfuscated)\n"
        code += "    private static let keyComponents: [[UInt8]] = [\n"
        for component in keyComponents {
            code += "        \(formatByteArray(component)),\n"
        }
        code += "    ]\n\n"
        
        // Add decryption methods
        code += """
            // Decrypt a credential at runtime
            public static func decrypt(_ key: CredentialKey) -> String? {
                guard let encryptedInfo = encryptedData[key] else { return nil }
                
                // Reconstruct the decryption key
                let keyData = keyComponents.flatMap { $0 }
                let symmetricKey = SymmetricKey(data: keyData)
                
                // Convert arrays to Data
                let encryptedData = Data(encryptedInfo.data)
                let nonce = try? AES.GCM.Nonce(data: Data(encryptedInfo.nonce))
                let tag = Data(encryptedInfo.tag)
                
                guard let nonce = nonce else { return nil }
                
                // Create sealed box for decryption
                let sealedBox = try? AES.GCM.SealedBox(
                    nonce: nonce,
                    ciphertext: encryptedData,
                    tag: tag
                )
                
                guard let sealedBox = sealedBox else { return nil }
                
                // Decrypt
                do {
                    let decryptedData = try AES.GCM.open(sealedBox, using: symmetricKey)
                    return String(data: decryptedData, encoding: .utf8)
                } catch {
                    return nil
                }
            }
            
            // Optional: Decrypt with caching
            private static var cache: [CredentialKey: String] = [:]
            
            public static func decryptCached(_ key: CredentialKey) -> String? {
                if let cached = cache[key] {
                    return cached
                }
                
                guard let decrypted = decrypt(key) else { return nil }
                cache[key] = decrypted
                return decrypted
            }
            
            // Clear cache when needed
            public static func clearCache() {
                cache.removeAll()
            }
        }
        """
        
        return code
    }
    
    private func formatByteArray(_ data: Data) -> String {
        let bytes = data.map { String(format: "0x%02X", $0) }
        
        // Format as single line if short
        if bytes.count <= 8 {
            return "[" + bytes.joined(separator: ", ") + "]"
        }
        
        // Format as multiple lines if long
        var result = "[\n                "
        for (index, byte) in bytes.enumerated() {
            if index > 0 && index % 8 == 0 {
                result += ",\n                "
            } else if index > 0 {
                result += ", "
            }
            result += byte
        }
        result += "\n            ]"
        return result
    }
    
    private func splitIntoComponents(_ data: Data, componentSize: Int) -> [Data] {
        var components: [Data] = []
        var offset = 0
        
        while offset < data.count {
            let remainingBytes = data.count - offset
            let size = min(componentSize, remainingBytes)
            components.append(data.subdata(in: offset..<(offset + size)))
            offset += size
        }
        
        return components
    }
}

enum CredentialError: Error {
    case invalidEncryptedData
    case decryptionFailed
}