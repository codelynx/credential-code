import Foundation
import CryptoKit

struct SwiftCodeGenerator: CodeGenerator {
    let language = "swift"
    let defaultFileName = "Generated/Credentials.swift"
    
    func generate(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Use the provided encryption key as the runtime key
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            // Convert plain text to data
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            // Encrypt with runtime key
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate Swift code
        return generateSwiftCode(
            credentials: encryptedCredentials,
            runtimeKey: encryptionKey
        )
    }
    
    func generateWithExternalKey(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Use the provided encryption key as the runtime key
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            // Convert plain text to data
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            // Encrypt with runtime key
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate Swift code without embedded key
        return generateSwiftCodeWithExternalKey(credentials: encryptedCredentials)
    }
    
    func generateWithExternalKeySource(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Use the provided encryption key as the runtime key
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            // Convert plain text to data
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            // Encrypt with runtime key
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate Swift code with external key source
        return generateSwiftCodeWithExternalKeySource(credentials: encryptedCredentials)
    }
    
    private func generateSwiftCode(credentials: [EncryptedCredential], runtimeKey: Data) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        import Foundation
        import CryptoKit
        
        public enum CredentialKey: String, CaseIterable {
        """
        
        // Add credential keys
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    case \(credential.key) = \"\(credential.key)\""
        }
        
        code += "\n}\n\n"
        
        // Add Credentials struct
        code += """
        public struct Credentials {
            // Encrypted credential data as byte arrays
            private static let encryptedData: [CredentialKey: (data: [UInt8], nonce: [UInt8], tag: [UInt8])] = [
        """
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        .\(credential.key): ("
            code += "\n            data: \(formatByteArray(credential.encryptedData)),"
            code += "\n            nonce: \(formatByteArray(credential.nonce)),"
            code += "\n            tag: \(formatByteArray(credential.tag))"
            code += "\n        ),"
        }
        
        code += "\n    ]\n\n"
        
        // Add obfuscated key
        let keyComponents = splitIntoComponents(runtimeKey, componentSize: 4)
        code += "    // Runtime decryption key (obfuscated)\n"
        code += "    private static let keyComponents: [[UInt8]] = [\n"
        for component in keyComponents {
            code += "        \(formatByteArray(component)),\n"
        }
        code += "    ]\n\n"
        
        // Add decryption methods
        code += """
            // Decrypt a credential at runtime
            public static func decrypt(_ key: CredentialKey) -> String? {
                guard let encryptedInfo = encryptedData[key] else { return nil }
                
                // Reconstruct the decryption key
                let keyData = keyComponents.flatMap { $0 }
                let symmetricKey = SymmetricKey(data: keyData)
                
                // Convert arrays to Data
                let encryptedData = Data(encryptedInfo.data)
                let nonce = try? AES.GCM.Nonce(data: Data(encryptedInfo.nonce))
                let tag = Data(encryptedInfo.tag)
                
                guard let nonce = nonce else { return nil }
                
                // Create sealed box for decryption
                let sealedBox = try? AES.GCM.SealedBox(
                    nonce: nonce,
                    ciphertext: encryptedData,
                    tag: tag
                )
                
                guard let sealedBox = sealedBox else { return nil }
                
                // Decrypt
                do {
                    let decryptedData = try AES.GCM.open(sealedBox, using: symmetricKey)
                    return String(data: decryptedData, encoding: .utf8)
                } catch {
                    return nil
                }
            }
            
            // Optional: Decrypt with caching
            private static var cache: [CredentialKey: String] = [:]
            
            public static func decryptCached(_ key: CredentialKey) -> String? {
                if let cached = cache[key] {
                    return cached
                }
                
                guard let decrypted = decrypt(key) else { return nil }
                cache[key] = decrypted
                return decrypted
            }
            
            // Clear cache when needed
            public static func clearCache() {
                cache.removeAll()
            }
        }
        """
        
        return code
    }
    
    private func formatByteArray(_ data: Data) -> String {
        let bytes = data.map { String(format: "0x%02X", $0) }
        
        // Format as single line if short
        if bytes.count <= 8 {
            return "[" + bytes.joined(separator: ", ") + "]"
        }
        
        // Format as multiple lines if long
        var result = "[\n                "
        for (index, byte) in bytes.enumerated() {
            if index > 0 && index % 8 == 0 {
                result += ",\n                "
            } else if index > 0 {
                result += ", "
            }
            result += byte
        }
        result += "\n            ]"
        return result
    }
    
    private func splitIntoComponents(_ data: Data, componentSize: Int) -> [Data] {
        var components: [Data] = []
        var offset = 0
        
        while offset < data.count {
            let remainingBytes = data.count - offset
            let size = min(componentSize, remainingBytes)
            components.append(data.subdata(in: offset..<(offset + size)))
            offset += size
        }
        
        return components
    }
    
    func generateKeySource(encryptionKey: Data) throws -> String {
        let base64Key = encryptionKey.base64EncodedString()
        
        return """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        // IMPORTANT: Keep this file secure and do not commit to version control
        
        import Foundation
        
        /// Provides the decryption key for credentials
        struct CredentialKeyProvider {
            /// The base64-encoded encryption key
            static let key = Data(base64Encoded: "\(base64Key)")!
        }
        """
    }
    
    private func generateSwiftCodeWithExternalKey(credentials: [EncryptedCredential]) -> String {
        var code = """
        // Auto-generated by credential-code (External Key Mode)
        // DO NOT EDIT - This file will be overwritten
        
        import Foundation
        import CryptoKit
        
        public enum CredentialKey: String, CaseIterable {
        """
        
        // Add credential keys
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    case \(credential.key) = \"\(credential.key)\""
        }
        
        code += "\n}\n\n"
        
        // Add Credentials struct with external key support
        code += """
        public struct Credentials {
            // Encrypted credential data as byte arrays
            private static let encryptedData: [CredentialKey: (data: [UInt8], nonce: [UInt8], tag: [UInt8])] = [
        """
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        .\(credential.key): ("
            code += "\n            data: \(formatByteArray(credential.encryptedData)),"
            code += "\n            nonce: \(formatByteArray(credential.nonce)),"
            code += "\n            tag: \(formatByteArray(credential.tag))"
            code += "\n        ),"
        }
        
        code += "\n    ]\n\n"
        
        // Add external key support
        code += """
            // External key support - must be initialized before use
            private static var externalKey: SymmetricKey?
            
            // Get the encryption key (must be initialized first)
            private static func getEncryptionKey() throws -> SymmetricKey {
                guard let key = externalKey else {
                    throw CredentialError.keyNotInitialized
                }
                return key
            }
            
            // Initialize with external key (for runtime initialization)
            public static func initialize(with keyData: Data) {
                externalKey = SymmetricKey(data: keyData)
            }
            
            // Initialize with base64 encoded key
            public static func initialize(with base64Key: String) throws {
                guard let keyData = Data(base64Encoded: base64Key) else {
                    throw CredentialError.invalidKey
                }
                initialize(with: keyData)
            }
            
            // Load key from file
            public static func loadKey(from filePath: String) throws {
                let url = URL(fileURLWithPath: filePath)
                let contents = try String(contentsOf: url, encoding: .utf8).trimmingCharacters(in: .whitespacesAndNewlines)
                
                // Try to parse as JSON first
                if let data = contents.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let keyString = json["key"] as? String {
                    try initialize(with: keyString)
                } else {
                    // Assume plain text base64 key
                    try initialize(with: contents)
                }
            }
            
            // Decrypt a credential at runtime
            public static func get(_ key: CredentialKey) throws -> String {
                let encryptionKey = try getEncryptionKey()
                
                guard let encrypted = encryptedData[key] else {
                    throw CredentialError.credentialNotFound
                }
                
                // Reconstruct the sealed box
                let nonce = try AES.GCM.Nonce(data: Data(encrypted.nonce))
                let sealedBox = try AES.GCM.SealedBox(
                    nonce: nonce,
                    ciphertext: Data(encrypted.data),
                    tag: Data(encrypted.tag)
                )
                
                // Decrypt
                let decryptedData = try AES.GCM.open(sealedBox, using: encryptionKey)
                
                guard let value = String(data: decryptedData, encoding: .utf8) else {
                    throw CredentialError.decryptionFailed
                }
                
                return value
            }
            
            // Get with operator
            public static subscript(key: CredentialKey) -> String? {
                try? get(key)
            }
            
            // Check if key is initialized
            public static var isInitialized: Bool {
                do {
                    _ = try getEncryptionKey()
                    return true
                } catch {
                    return false
                }
            }
        }
        
        // Extended error cases
        enum CredentialError: Error {
            case invalidKey
            case keyNotInitialized
            case credentialNotFound
            case invalidEncryptedData
            case decryptionFailed
        }
        """
        
        return code
    }
    
    private func generateSwiftCodeWithExternalKeySource(credentials: [EncryptedCredential]) -> String {
        var code = """
        // Auto-generated by credential-code (External Key Source Mode)
        // DO NOT EDIT - This file will be overwritten
        
        import Foundation
        import CryptoKit
        
        public enum CredentialKey: String, CaseIterable {
        """
        
        // Add credential keys
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    case \(credential.key) = \"\(credential.key)\""
        }
        
        code += "\n}\n\n"
        
        // Add Credentials struct with external key source support
        code += """
        public struct Credentials {
            // Encrypted credential data as byte arrays
            private static let encryptedData: [CredentialKey: (data: [UInt8], nonce: [UInt8], tag: [UInt8])] = [
        """
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        .\(credential.key): ("
            code += "\n            data: \(formatByteArray(credential.encryptedData)),"
            code += "\n            nonce: \(formatByteArray(credential.nonce)),"
            code += "\n            tag: \(formatByteArray(credential.tag))"
            code += "\n        ),"
        }
        
        code += "\n    ]\n\n"
        
        // Add external key source support
        code += """
            // Get encryption key from CredentialKeyProvider
            private static func getEncryptionKey() throws -> SymmetricKey {
                // When using external key source, CredentialKeyProvider should be included in compilation
                // This will cause a compile error if CredentialKeyProvider is not available,
                // which is the intended behavior
                return SymmetricKey(data: CredentialKeyProvider.key)
            }
            
            // Decrypt a credential at runtime
            public static func get(_ key: CredentialKey) throws -> String {
                let encryptionKey = try getEncryptionKey()
                
                guard let encrypted = encryptedData[key] else {
                    throw CredentialError.credentialNotFound
                }
                
                // Reconstruct the sealed box
                let nonce = try AES.GCM.Nonce(data: Data(encrypted.nonce))
                let sealedBox = try AES.GCM.SealedBox(
                    nonce: nonce,
                    ciphertext: Data(encrypted.data),
                    tag: Data(encrypted.tag)
                )
                
                // Decrypt
                let decryptedData = try AES.GCM.open(sealedBox, using: encryptionKey)
                
                guard let value = String(data: decryptedData, encoding: .utf8) else {
                    throw CredentialError.decryptionFailed
                }
                
                return value
            }
            
            // Convenience subscript access
            public static subscript(key: CredentialKey) -> String? {
                try? get(key)
            }
        }
        
        // Error cases
        enum CredentialError: Error {
            case credentialNotFound
            case invalidEncryptedData
            case decryptionFailed
        }
        """
        
        return code
    }
}

enum CredentialError: Error {
    case invalidEncryptedData
    case decryptionFailed
    case notImplemented(String)
}