import Foundation
import CryptoKit

struct CppCodeGenerator: CodeGenerator {
    let language = "c++"
    let defaultFileName = "Generated/credentials.cpp"
    
    func generate(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Use the provided encryption key as the runtime key
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            // Convert plain text to data
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            // Encrypt with runtime key
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate header and implementation
        let headerContent = generateCppHeader(credentials: encryptedCredentials)
        let implContent = generateCppImplementation(
            credentials: encryptedCredentials,
            runtimeKey: encryptionKey
        )
        
        // For now, return just the implementation (in real usage, we'd write both files)
        return "// credentials.h\n" + headerContent + "\n\n// credentials.cpp\n" + implContent
    }
    
    private func generateCppHeader(credentials: [EncryptedCredential]) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        #ifndef CREDENTIALS_H
        #define CREDENTIALS_H
        
        #include <string>
        #include <optional>
        #include <unordered_map>
        
        enum class CredentialKey {
        """
        
        // Add credential keys
        for (index, credential) in credentials.sorted(by: { $0.key < $1.key }).enumerated() {
            code += "\n    \(credential.key)"
            if index < credentials.count - 1 {
                code += ","
            }
        }
        
        code += """
        
        };
        
        class Credentials {
        public:
            static std::optional<std::string> decrypt(CredentialKey key);
            static std::optional<std::string> decryptCached(CredentialKey key);
            static void clearCache();
            
        private:
            static std::unordered_map<CredentialKey, std::string> cache;
        };
        
        #endif // CREDENTIALS_H
        """
        
        return code
    }
    
    private func generateCppImplementation(credentials: [EncryptedCredential], runtimeKey: Data) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        #include "credentials.h"
        #include <vector>
        #include <cstring>
        #include <openssl/evp.h>
        #include <openssl/aes.h>
        
        namespace {
            struct EncryptedData {
                std::vector<uint8_t> data;
                std::vector<uint8_t> nonce;
                std::vector<uint8_t> tag;
            };
            
            const std::unordered_map<CredentialKey, EncryptedData> encryptedData = {
        """
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        {CredentialKey::\(credential.key), {"
            code += "\n            \(formatCppVector(credential.encryptedData, name: "data")),"
            code += "\n            \(formatCppVector(credential.nonce, name: "nonce")),"
            code += "\n            \(formatCppVector(credential.tag, name: "tag"))"
            code += "\n        }},"
        }
        
        code += "\n    };\n\n"
        
        // Add key components
        let keyComponents = splitIntoComponents(runtimeKey, componentSize: 4)
        code += "    // Runtime decryption key (obfuscated)\n"
        code += "    const std::vector<std::vector<uint8_t>> keyComponents = {\n"
        for component in keyComponents {
            code += "        \(formatCppVector(component)),\n"
        }
        code += "    };\n"
        
        // Add decryption implementation
        code += """
        
            std::vector<uint8_t> reconstructKey() {
                std::vector<uint8_t> key;
                for (const auto& component : keyComponents) {
                    key.insert(key.end(), component.begin(), component.end());
                }
                return key;
            }
        }
        
        std::unordered_map<CredentialKey, std::string> Credentials::cache;
        
        std::optional<std::string> Credentials::decrypt(CredentialKey key) {
            auto it = encryptedData.find(key);
            if (it == encryptedData.end()) {
                return std::nullopt;
            }
            
            const auto& encrypted = it->second;
            auto keyData = reconstructKey();
            
            EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
            if (!ctx) return std::nullopt;
            
            // Initialize AES-GCM decryption
            if (!EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, keyData.data(), encrypted.nonce.data())) {
                EVP_CIPHER_CTX_free(ctx);
                return std::nullopt;
            }
            
            // Allocate output buffer
            std::vector<uint8_t> plaintext(encrypted.data.size());
            int len;
            
            // Decrypt
            if (!EVP_DecryptUpdate(ctx, plaintext.data(), &len, encrypted.data.data(), encrypted.data.size())) {
                EVP_CIPHER_CTX_free(ctx);
                return std::nullopt;
            }
            
            // Set tag
            if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, encrypted.tag.size(), 
                                     const_cast<uint8_t*>(encrypted.tag.data()))) {
                EVP_CIPHER_CTX_free(ctx);
                return std::nullopt;
            }
            
            // Finalize
            int finalLen;
            if (!EVP_DecryptFinal_ex(ctx, plaintext.data() + len, &finalLen)) {
                EVP_CIPHER_CTX_free(ctx);
                return std::nullopt;
            }
            
            EVP_CIPHER_CTX_free(ctx);
            
            return std::string(plaintext.begin(), plaintext.begin() + len + finalLen);
        }
        
        std::optional<std::string> Credentials::decryptCached(CredentialKey key) {
            auto cached = cache.find(key);
            if (cached != cache.end()) {
                return cached->second;
            }
            
            auto decrypted = decrypt(key);
            if (decrypted) {
                cache[key] = *decrypted;
            }
            return decrypted;
        }
        
        void Credentials::clearCache() {
            cache.clear();
        }
        """
        
        return code
    }
    
    private func formatCppVector(_ data: Data, name: String? = nil) -> String {
        let bytes = data.map { String(format: "0x%02X", $0) }
        
        let prefix = name.map { "/*\($0)*/ " } ?? ""
        
        // Format as single line if short
        if bytes.count <= 8 {
            return prefix + "{" + bytes.joined(separator: ", ") + "}"
        }
        
        // Format as multiple lines if long
        var result = prefix + "{\n                "
        for (index, byte) in bytes.enumerated() {
            if index > 0 && index % 8 == 0 {
                result += ",\n                "
            } else if index > 0 {
                result += ", "
            }
            result += byte
        }
        result += "\n            }"
        return result
    }
    
    private func splitIntoComponents(_ data: Data, componentSize: Int) -> [Data] {
        var components: [Data] = []
        var offset = 0
        
        while offset < data.count {
            let remainingBytes = data.count - offset
            let size = min(componentSize, remainingBytes)
            components.append(data.subdata(in: offset..<(offset + size)))
            offset += size
        }
        
        return components
    }
    
    func generateWithExternalKey(credentials: [String: String], encryptionKey: Data) throws -> String {
        throw CredentialError.notImplemented("External key generation is not yet implemented for C++")
    }
    
    func generateWithExternalKeySource(credentials: [String: String], encryptionKey: Data) throws -> String {
        throw CredentialError.notImplemented("External key source generation for C++")
    }
    
    func generateKeySource(encryptionKey: Data) throws -> String {
        throw CredentialError.notImplemented("Key source generation is not yet implemented for C++")
    }
}