import Foundation
import CryptoKit

struct CppCodeGenerator: CodeGenerator {
    let language = "c++"
    let defaultFileName = "Generated/credentials.cpp"
    
    func generate(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Use the provided encryption key as the runtime key
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            // Convert plain text to data
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            // Encrypt with runtime key
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate header and implementation
        let headerContent = generateCppHeader(credentials: encryptedCredentials)
        let implContent = generateCppImplementation(
            credentials: encryptedCredentials,
            runtimeKey: encryptionKey
        )
        
        // For now, return just the implementation (in real usage, we'd write both files)
        return "// credentials.h\n" + headerContent + "\n\n// credentials.cpp\n" + implContent
    }
    
    private func generateCppHeader(credentials: [EncryptedCredential]) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        #ifndef CREDENTIALS_H
        #define CREDENTIALS_H
        
        #include <string>
        #include <optional>
        #include <unordered_map>
        
        enum class CredentialKey {
        """
        
        // Add credential keys
        for (index, credential) in credentials.sorted(by: { $0.key < $1.key }).enumerated() {
            code += "\n    \(credential.key)"
            if index < credentials.count - 1 {
                code += ","
            }
        }
        
        code += """
        
        };
        
        class Credentials {
        public:
            static std::optional<std::string> decrypt(CredentialKey key);
            static std::optional<std::string> decryptCached(CredentialKey key);
            static void clearCache();
            
        private:
            static std::unordered_map<CredentialKey, std::string> cache;
        };
        
        #endif // CREDENTIALS_H
        """
        
        return code
    }
    
    private func generateCppImplementation(credentials: [EncryptedCredential], runtimeKey: Data) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        #include "credentials.h"
        #include <vector>
        #include <cstring>
        #include <openssl/evp.h>
        #include <openssl/aes.h>
        
        namespace {
            struct EncryptedData {
                std::vector<uint8_t> data;
                std::vector<uint8_t> nonce;
                std::vector<uint8_t> tag;
            };
            
            const std::unordered_map<CredentialKey, EncryptedData> encryptedData = {
        """
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        {CredentialKey::\(credential.key), {"
            code += "\n            \(formatCppVector(credential.encryptedData, name: "data")),"
            code += "\n            \(formatCppVector(credential.nonce, name: "nonce")),"
            code += "\n            \(formatCppVector(credential.tag, name: "tag"))"
            code += "\n        }},"
        }
        
        code += "\n    };\n\n"
        
        // Add key components
        let keyComponents = splitIntoComponents(runtimeKey, componentSize: 4)
        code += "    // Runtime decryption key (obfuscated)\n"
        code += "    const std::vector<std::vector<uint8_t>> keyComponents = {\n"
        for component in keyComponents {
            code += "        \(formatCppVector(component)),\n"
        }
        code += "    };\n"
        
        // Add decryption implementation
        code += """
        
            std::vector<uint8_t> reconstructKey() {
                std::vector<uint8_t> key;
                for (const auto& component : keyComponents) {
                    key.insert(key.end(), component.begin(), component.end());
                }
                return key;
            }
        }
        
        std::unordered_map<CredentialKey, std::string> Credentials::cache;
        
        std::optional<std::string> Credentials::decrypt(CredentialKey key) {
            auto it = encryptedData.find(key);
            if (it == encryptedData.end()) {
                return std::nullopt;
            }
            
            const auto& encrypted = it->second;
            auto keyData = reconstructKey();
            
            EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
            if (!ctx) return std::nullopt;
            
            // Initialize AES-GCM decryption
            if (!EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, keyData.data(), encrypted.nonce.data())) {
                EVP_CIPHER_CTX_free(ctx);
                return std::nullopt;
            }
            
            // Allocate output buffer
            std::vector<uint8_t> plaintext(encrypted.data.size());
            int len;
            
            // Decrypt
            if (!EVP_DecryptUpdate(ctx, plaintext.data(), &len, encrypted.data.data(), encrypted.data.size())) {
                EVP_CIPHER_CTX_free(ctx);
                return std::nullopt;
            }
            
            // Set tag
            if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, encrypted.tag.size(), 
                                     const_cast<uint8_t*>(encrypted.tag.data()))) {
                EVP_CIPHER_CTX_free(ctx);
                return std::nullopt;
            }
            
            // Finalize
            int finalLen;
            if (!EVP_DecryptFinal_ex(ctx, plaintext.data() + len, &finalLen)) {
                EVP_CIPHER_CTX_free(ctx);
                return std::nullopt;
            }
            
            EVP_CIPHER_CTX_free(ctx);
            
            return std::string(plaintext.begin(), plaintext.begin() + len + finalLen);
        }
        
        std::optional<std::string> Credentials::decryptCached(CredentialKey key) {
            auto cached = cache.find(key);
            if (cached != cache.end()) {
                return cached->second;
            }
            
            auto decrypted = decrypt(key);
            if (decrypted) {
                cache[key] = *decrypted;
            }
            return decrypted;
        }
        
        void Credentials::clearCache() {
            cache.clear();
        }
        """
        
        return code
    }
    
    private func formatCppVector(_ data: Data, name: String? = nil) -> String {
        let bytes = data.map { String(format: "0x%02X", $0) }
        
        let prefix = name.map { "/*\($0)*/ " } ?? ""
        
        // Format as single line if short
        if bytes.count <= 8 {
            return prefix + "{" + bytes.joined(separator: ", ") + "}"
        }
        
        // Format as multiple lines if long
        var result = prefix + "{\n                "
        for (index, byte) in bytes.enumerated() {
            if index > 0 && index % 8 == 0 {
                result += ",\n                "
            } else if index > 0 {
                result += ", "
            }
            result += byte
        }
        result += "\n            }"
        return result
    }
    
    private func splitIntoComponents(_ data: Data, componentSize: Int) -> [Data] {
        var components: [Data] = []
        var offset = 0
        
        while offset < data.count {
            let remainingBytes = data.count - offset
            let size = min(componentSize, remainingBytes)
            components.append(data.subdata(in: offset..<(offset + size)))
            offset += size
        }
        
        return components
    }
    
    private func generateCppHeaderWithExternalKey(credentials: [EncryptedCredential]) -> String {
        var code = """
// Auto-generated by credential-code
// DO NOT EDIT - This file will be overwritten

#ifndef CREDENTIALS_H
#define CREDENTIALS_H

#include <string>
#include <optional>
#include <unordered_map>
#include <vector>
#include <cstdint>
#include <stdexcept>

enum class CredentialKey {
"""
        
        // Add credential keys
        for (index, credential) in credentials.sorted(by: { $0.key < $1.key }).enumerated() {
            code += "\n    \(credential.key)"
            if index < credentials.count - 1 {
                code += ","
            }
        }
        
        code += """

};

class CredentialException : public std::runtime_error {
public:
    explicit CredentialException(const std::string& message) : std::runtime_error(message) {}
};

class Credentials {
public:
    // Initialize with raw key data
    static void initialize(const std::vector<uint8_t>& keyData);
    
    // Initialize with base64 encoded key
    static void initialize(const std::string& base64Key);
    
    // Load key from file (JSON or plain text)
    static void loadKey(const std::string& filePath);
    
    // Check if initialized
    static bool isInitialized();
    
    // Get decrypted credential
    static std::string get(CredentialKey key);
    
    // Optional: Get with caching
    static std::string getCached(CredentialKey key);
    static void clearCache();
    
private:
    static std::optional<std::vector<uint8_t>> externalKey;
    static std::unordered_map<CredentialKey, std::string> cache;
};

#endif // CREDENTIALS_H
"""
        
        return code
    }
    
    private func generateCppImplementationWithExternalKey(credentials: [EncryptedCredential]) -> String {
        var code = """
// Auto-generated by credential-code
// DO NOT EDIT - This file will be overwritten

#include "credentials.h"
#include <fstream>
#include <sstream>
#include <openssl/evp.h>
#include <openssl/aes.h>
#include <nlohmann/json.hpp>

namespace {
    struct EncryptedData {
        std::vector<uint8_t> data;
        std::vector<uint8_t> nonce;
        std::vector<uint8_t> tag;
    };
    
    const std::unordered_map<CredentialKey, EncryptedData> encryptedData = {
"""
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        {CredentialKey::\(credential.key), {"
            code += "\n            \(formatCppVector(credential.encryptedData, name: "data")),"
            code += "\n            \(formatCppVector(credential.nonce, name: "nonce")),"
            code += "\n            \(formatCppVector(credential.tag, name: "tag"))"
            code += "\n        }},"
        }
        
        code += """
    };
    
    // Base64 decoding helper
    std::vector<uint8_t> base64Decode(const std::string& encoded) {
        const std::string base64_chars = 
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        
        std::vector<uint8_t> ret;
        int val = 0, valb = -8;
        for (unsigned char c : encoded) {
            if (c == '=') break;
            auto pos = base64_chars.find(c);
            if (pos == std::string::npos) continue;
            val = (val << 6) + pos;
            valb += 6;
            if (valb >= 0) {
                ret.push_back(char((val >> valb) & 0xFF));
                valb -= 8;
            }
        }
        return ret;
    }
}

std::optional<std::vector<uint8_t>> Credentials::externalKey;
std::unordered_map<CredentialKey, std::string> Credentials::cache;

void Credentials::initialize(const std::vector<uint8_t>& keyData) {
    externalKey = keyData;
}

void Credentials::initialize(const std::string& base64Key) {
    initialize(base64Decode(base64Key));
}

void Credentials::loadKey(const std::string& filePath) {
    std::ifstream file(filePath);
    if (!file.is_open()) {
        throw CredentialException("Failed to open key file: " + filePath);
    }
    
    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string contents = buffer.str();
    
    // Trim whitespace
    contents.erase(0, contents.find_first_not_of(" \\n\\r\\t"));
    contents.erase(contents.find_last_not_of(" \\n\\r\\t") + 1);
    
    // Try to parse as JSON first
    std::string base64Key;
    try {
        auto json = nlohmann::json::parse(contents);
        base64Key = json["key"];
    } catch (...) {
        // If not JSON, use as plain base64 string
        base64Key = contents;
    }
    
    initialize(base64Key);
}

bool Credentials::isInitialized() {
    return externalKey.has_value();
}

std::string Credentials::get(CredentialKey key) {
    if (!externalKey) {
        throw CredentialException("Credentials not initialized. Call initialize() or loadKey() first.");
    }
    
    auto it = encryptedData.find(key);
    if (it == encryptedData.end()) {
        throw CredentialException("Credential not found");
    }
    
    const auto& encrypted = it->second;
    const auto& keyData = *externalKey;
    
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) throw CredentialException("Failed to create cipher context");
    
    // Initialize AES-GCM decryption
    if (!EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, keyData.data(), encrypted.nonce.data())) {
        EVP_CIPHER_CTX_free(ctx);
        throw CredentialException("Failed to initialize decryption");
    }
    
    // Allocate output buffer
    std::vector<uint8_t> plaintext(encrypted.data.size());
    int len;
    
    // Decrypt
    if (!EVP_DecryptUpdate(ctx, plaintext.data(), &len, encrypted.data.data(), encrypted.data.size())) {
        EVP_CIPHER_CTX_free(ctx);
        throw CredentialException("Failed to decrypt");
    }
    
    // Set tag
    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, encrypted.tag.size(), 
                             const_cast<uint8_t*>(encrypted.tag.data()))) {
        EVP_CIPHER_CTX_free(ctx);
        throw CredentialException("Failed to set tag");
    }
    
    // Finalize
    int finalLen;
    if (!EVP_DecryptFinal_ex(ctx, plaintext.data() + len, &finalLen)) {
        EVP_CIPHER_CTX_free(ctx);
        throw CredentialException("Failed to finalize decryption");
    }
    
    EVP_CIPHER_CTX_free(ctx);
    
    return std::string(plaintext.begin(), plaintext.begin() + len + finalLen);
}

std::string Credentials::getCached(CredentialKey key) {
    auto cached = cache.find(key);
    if (cached != cache.end()) {
        return cached->second;
    }
    
    auto decrypted = get(key);
    cache[key] = decrypted;
    return decrypted;
}

void Credentials::clearCache() {
    cache.clear();
}
"""
        
        return code
    }
    
    private func generateCppHeaderWithExternalKeySource(credentials: [EncryptedCredential]) -> String {
        // Similar to regular header but without initialization methods
        var code = """
// Auto-generated by credential-code
// DO NOT EDIT - This file will be overwritten

#ifndef CREDENTIALS_H
#define CREDENTIALS_H

#include <string>
#include <optional>
#include <unordered_map>

enum class CredentialKey {
"""
        
        // Add credential keys
        for (index, credential) in credentials.sorted(by: { $0.key < $1.key }).enumerated() {
            code += "\n    \(credential.key)"
            if index < credentials.count - 1 {
                code += ","
            }
        }
        
        code += """

};

class Credentials {
public:
    static std::optional<std::string> decrypt(CredentialKey key);
    static std::optional<std::string> decryptCached(CredentialKey key);
    static void clearCache();
    
private:
    static std::unordered_map<CredentialKey, std::string> cache;
};

#endif // CREDENTIALS_H
"""
        
        return code
    }
    
    private func generateCppImplementationWithExternalKeySource(credentials: [EncryptedCredential]) -> String {
        var code = """
// Auto-generated by credential-code
// DO NOT EDIT - This file will be overwritten

#include "credentials.h"
#include "credential_key.h"
#include <vector>
#include <cstring>
#include <openssl/evp.h>
#include <openssl/aes.h>

namespace {
    struct EncryptedData {
        std::vector<uint8_t> data;
        std::vector<uint8_t> nonce;
        std::vector<uint8_t> tag;
    };
    
    const std::unordered_map<CredentialKey, EncryptedData> encryptedData = {
"""
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        {CredentialKey::\(credential.key), {"
            code += "\n            \(formatCppVector(credential.encryptedData, name: "data")),"
            code += "\n            \(formatCppVector(credential.nonce, name: "nonce")),"
            code += "\n            \(formatCppVector(credential.tag, name: "tag"))"
            code += "\n        }},"
        }
        
        code += """
    };
}

std::unordered_map<CredentialKey, std::string> Credentials::cache;

std::optional<std::string> Credentials::decrypt(CredentialKey key) {
    auto it = encryptedData.find(key);
    if (it == encryptedData.end()) {
        return std::nullopt;
    }
    
    const auto& encrypted = it->second;
    auto keyData = CredentialKeyProvider::getKey();
    
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) return std::nullopt;
    
    // Initialize AES-GCM decryption
    if (!EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, keyData.data(), encrypted.nonce.data())) {
        EVP_CIPHER_CTX_free(ctx);
        return std::nullopt;
    }
    
    // Allocate output buffer
    std::vector<uint8_t> plaintext(encrypted.data.size());
    int len;
    
    // Decrypt
    if (!EVP_DecryptUpdate(ctx, plaintext.data(), &len, encrypted.data.data(), encrypted.data.size())) {
        EVP_CIPHER_CTX_free(ctx);
        return std::nullopt;
    }
    
    // Set tag
    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, encrypted.tag.size(), 
                             const_cast<uint8_t*>(encrypted.tag.data()))) {
        EVP_CIPHER_CTX_free(ctx);
        return std::nullopt;
    }
    
    // Finalize
    int finalLen;
    if (!EVP_DecryptFinal_ex(ctx, plaintext.data() + len, &finalLen)) {
        EVP_CIPHER_CTX_free(ctx);
        return std::nullopt;
    }
    
    EVP_CIPHER_CTX_free(ctx);
    
    return std::string(plaintext.begin(), plaintext.begin() + len + finalLen);
}

std::optional<std::string> Credentials::decryptCached(CredentialKey key) {
    auto cached = cache.find(key);
    if (cached != cache.end()) {
        return cached->second;
    }
    
    auto decrypted = decrypt(key);
    if (decrypted) {
        cache[key] = *decrypted;
    }
    return decrypted;
}

void Credentials::clearCache() {
    cache.clear();
}
"""
        
        return code
    }
    
    func generateWithExternalKey(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Encrypt credentials
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate header and implementation
        let headerContent = generateCppHeaderWithExternalKey(credentials: encryptedCredentials)
        let implContent = generateCppImplementationWithExternalKey(credentials: encryptedCredentials)
        
        return "// credentials.h\n" + headerContent + "\n\n// credentials.cpp\n" + implContent
    }
    
    func generateWithExternalKeySource(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Similar to external key but expects key from source
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate header and implementation
        let headerContent = generateCppHeaderWithExternalKeySource(credentials: encryptedCredentials)
        let implContent = generateCppImplementationWithExternalKeySource(credentials: encryptedCredentials)
        
        return "// credentials.h\n" + headerContent + "\n\n// credentials.cpp\n" + implContent
    }
    
    func generateKeySource(encryptionKey: Data) throws -> String {
        let base64Key = encryptionKey.base64EncodedString()
        
        return """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        #ifndef CREDENTIAL_KEY_H
        #define CREDENTIAL_KEY_H
        
        #include <vector>
        #include <cstdint>
        #include <string>
        
        namespace CredentialKeyProvider {
            // Base64 encoded key
            const std::string base64Key = "\(base64Key)";
            
            // Helper function to decode base64 to bytes
            std::vector<uint8_t> getKey();
        }
        
        #endif // CREDENTIAL_KEY_H
        
        // credential_key.cpp
        #include "credential_key.h"
        #include <algorithm>
        
        namespace CredentialKeyProvider {
            std::vector<uint8_t> getKey() {
                // Simple base64 decode implementation
                const std::string base64_chars = 
                    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                
                std::vector<uint8_t> ret;
                int val = 0, valb = -8;
                for (unsigned char c : base64Key) {
                    if (c == '=') break;
                    auto pos = base64_chars.find(c);
                    if (pos == std::string::npos) continue;
                    val = (val << 6) + pos;
                    valb += 6;
                    if (valb >= 0) {
                        ret.push_back(char((val >> valb) & 0xFF));
                        valb -= 8;
                    }
                }
                return ret;
            }
        }
        """
    }
}