import Foundation
import CryptoKit

struct KotlinCodeGenerator: CodeGenerator {
    let language = "kotlin"
    let defaultFileName = "Generated/Credentials.kt"
    
    func generate(credentials: [String: String], encryptionKey: Data) throws -> String {
        // First, decrypt and re-encrypt all credentials with a new runtime key
        let runtimeKey = SymmetricKey(size: .bits256)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, encryptedValue) in credentials {
            // Decode the stored encrypted value
            guard let combinedData = Data(base64Encoded: encryptedValue) else {
                throw CredentialError.invalidEncryptedData
            }
            
            // Extract nonce (12 bytes), ciphertext, and tag (16 bytes)
            let nonceSize = 12
            let tagSize = 16
            
            guard combinedData.count > nonceSize + tagSize else {
                throw CredentialError.invalidEncryptedData
            }
            
            let nonce = combinedData.prefix(nonceSize)
            let ciphertext = combinedData.dropFirst(nonceSize).dropLast(tagSize)
            let tag = combinedData.suffix(tagSize)
            
            // Decrypt with storage key
            let storageKey = SymmetricKey(data: encryptionKey)
            let sealedBox = try AES.GCM.SealedBox(
                nonce: AES.GCM.Nonce(data: nonce),
                ciphertext: ciphertext,
                tag: tag
            )
            let plaintext = try AES.GCM.open(sealedBox, using: storageKey)
            
            // Re-encrypt with runtime key
            let newSealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: newSealedBox.ciphertext,
                nonce: newSealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: newSealedBox.tag
            ))
        }
        
        // Generate Kotlin code
        return generateKotlinCode(
            credentials: encryptedCredentials,
            runtimeKey: runtimeKey.withUnsafeBytes { Data($0) }
        )
    }
    
    private func generateKotlinCode(credentials: [EncryptedCredential], runtimeKey: Data) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        package com.example.credentials
        
        import javax.crypto.Cipher
        import javax.crypto.spec.GCMParameterSpec
        import javax.crypto.spec.SecretKeySpec
        
        enum class CredentialKey {
        """
        
        // Add credential keys
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    \(credential.key),"
        }
        
        code += "\n}\n\n"
        
        // Add Credentials object
        code += """
        object Credentials {
            private data class EncryptedData(
                val data: ByteArray,
                val nonce: ByteArray,
                val tag: ByteArray
            )
            
            // Encrypted credential data as byte arrays
            private val encryptedData = mapOf(
        """
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        CredentialKey.\(credential.key) to EncryptedData("
            code += "\n            data = \(formatKotlinByteArray(credential.encryptedData)),"
            code += "\n            nonce = \(formatKotlinByteArray(credential.nonce)),"
            code += "\n            tag = \(formatKotlinByteArray(credential.tag))"
            code += "\n        ),"
        }
        
        code += "\n    )\n\n"
        
        // Add obfuscated key
        let keyComponents = splitIntoComponents(runtimeKey, componentSize: 4)
        code += "    // Runtime decryption key (obfuscated)\n"
        code += "    private val keyComponents = arrayOf(\n"
        for component in keyComponents {
            code += "        \(formatKotlinByteArray(component)),\n"
        }
        code += "    )\n\n"
        
        // Add decryption methods
        code += """
            @JvmStatic
            fun decrypt(key: CredentialKey): String? {
                val encrypted = encryptedData[key] ?: return null
                
                return try {
                    // Reconstruct the decryption key
                    val keyData = keyComponents.flatMap { it.toList() }.toByteArray()
                    val secretKey = SecretKeySpec(keyData, "AES")
                    
                    // Setup cipher for AES-GCM
                    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
                    val gcmSpec = GCMParameterSpec(128, encrypted.nonce)
                    cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec)
                    
                    // Combine ciphertext and tag for decryption
                    val cipherTextWithTag = encrypted.data + encrypted.tag
                    val decrypted = cipher.doFinal(cipherTextWithTag)
                    
                    String(decrypted, Charsets.UTF_8)
                } catch (e: Exception) {
                    null
                }
            }
            
            // Optional: Decrypt with caching
            private val cache = mutableMapOf<CredentialKey, String>()
            
            @JvmStatic
            fun decryptCached(key: CredentialKey): String? {
                cache[key]?.let { return it }
                
                val decrypted = decrypt(key) ?: return null
                cache[key] = decrypted
                return decrypted
            }
            
            // Clear cache when needed
            @JvmStatic
            fun clearCache() {
                cache.clear()
            }
        }
        """
        
        return code
    }
    
    private func formatKotlinByteArray(_ data: Data) -> String {
        let bytes = data.map { byte in
            let value = Int8(bitPattern: byte)
            return value < 0 ? "\(value)" : "0x\(String(format: "%02X", byte))"
        }
        
        // Format as single line if short
        if bytes.count <= 8 {
            return "byteArrayOf(" + bytes.joined(separator: ", ") + ")"
        }
        
        // Format as multiple lines if long
        var result = "byteArrayOf(\n                "
        for (index, byte) in bytes.enumerated() {
            if index > 0 && index % 8 == 0 {
                result += ",\n                "
            } else if index > 0 {
                result += ", "
            }
            result += byte
        }
        result += "\n            )"
        return result
    }
    
    private func splitIntoComponents(_ data: Data, componentSize: Int) -> [Data] {
        var components: [Data] = []
        var offset = 0
        
        while offset < data.count {
            let remainingBytes = data.count - offset
            let size = min(componentSize, remainingBytes)
            components.append(data.subdata(in: offset..<(offset + size)))
            offset += size
        }
        
        return components
    }
}