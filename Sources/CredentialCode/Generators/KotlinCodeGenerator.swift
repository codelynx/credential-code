import Foundation
import CryptoKit

struct KotlinCodeGenerator: CodeGenerator {
    let language = "kotlin"
    let defaultFileName = "Generated/Credentials.kt"
    
    func generate(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Use the provided encryption key as the runtime key
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            // Convert plain text to data
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            // Encrypt with runtime key
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate Kotlin code
        return generateKotlinCode(
            credentials: encryptedCredentials,
            runtimeKey: encryptionKey
        )
    }
    
    private func generateKotlinCode(credentials: [EncryptedCredential], runtimeKey: Data) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        package com.example.credentials
        
        import javax.crypto.Cipher
        import javax.crypto.spec.GCMParameterSpec
        import javax.crypto.spec.SecretKeySpec
        
        enum class CredentialKey {
        """
        
        // Add credential keys
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    \(credential.key),"
        }
        
        code += "\n}\n\n"
        
        // Add Credentials object
        code += """
        object Credentials {
            private data class EncryptedData(
                val data: ByteArray,
                val nonce: ByteArray,
                val tag: ByteArray
            )
            
            // Encrypted credential data as byte arrays
            private val encryptedData = mapOf(
        """
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        CredentialKey.\(credential.key) to EncryptedData("
            code += "\n            data = \(formatKotlinByteArray(credential.encryptedData)),"
            code += "\n            nonce = \(formatKotlinByteArray(credential.nonce)),"
            code += "\n            tag = \(formatKotlinByteArray(credential.tag))"
            code += "\n        ),"
        }
        
        code += "\n    )\n\n"
        
        // Add obfuscated key
        let keyComponents = splitIntoComponents(runtimeKey, componentSize: 4)
        code += "    // Runtime decryption key (obfuscated)\n"
        code += "    private val keyComponents = arrayOf(\n"
        for component in keyComponents {
            code += "        \(formatKotlinByteArray(component)),\n"
        }
        code += "    )\n\n"
        
        // Add decryption methods
        code += """
            @JvmStatic
            fun decrypt(key: CredentialKey): String? {
                val encrypted = encryptedData[key] ?: return null
                
                return try {
                    // Reconstruct the decryption key
                    val keyData = keyComponents.flatMap { it.toList() }.toByteArray()
                    val secretKey = SecretKeySpec(keyData, "AES")
                    
                    // Setup cipher for AES-GCM
                    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
                    val gcmSpec = GCMParameterSpec(128, encrypted.nonce)
                    cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec)
                    
                    // Combine ciphertext and tag for decryption
                    val cipherTextWithTag = encrypted.data + encrypted.tag
                    val decrypted = cipher.doFinal(cipherTextWithTag)
                    
                    String(decrypted, Charsets.UTF_8)
                } catch (e: Exception) {
                    null
                }
            }
            
            // Optional: Decrypt with caching
            private val cache = mutableMapOf<CredentialKey, String>()
            
            @JvmStatic
            fun decryptCached(key: CredentialKey): String? {
                cache[key]?.let { return it }
                
                val decrypted = decrypt(key) ?: return null
                cache[key] = decrypted
                return decrypted
            }
            
            // Clear cache when needed
            @JvmStatic
            fun clearCache() {
                cache.clear()
            }
        }
        """
        
        return code
    }
    
    private func formatKotlinByteArray(_ data: Data) -> String {
        let bytes = data.map { byte in
            let value = Int8(bitPattern: byte)
            return value < 0 ? "\(value)" : "0x\(String(format: "%02X", byte))"
        }
        
        // Format as single line if short
        if bytes.count <= 8 {
            return "byteArrayOf(" + bytes.joined(separator: ", ") + ")"
        }
        
        // Format as multiple lines if long
        var result = "byteArrayOf(\n                "
        for (index, byte) in bytes.enumerated() {
            if index > 0 && index % 8 == 0 {
                result += ",\n                "
            } else if index > 0 {
                result += ", "
            }
            result += byte
        }
        result += "\n            )"
        return result
    }
    
    private func splitIntoComponents(_ data: Data, componentSize: Int) -> [Data] {
        var components: [Data] = []
        var offset = 0
        
        while offset < data.count {
            let remainingBytes = data.count - offset
            let size = min(componentSize, remainingBytes)
            components.append(data.subdata(in: offset..<(offset + size)))
            offset += size
        }
        
        return components
    }
    
    private func generateKotlinCodeWithExternalKey(credentials: [EncryptedCredential]) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        package com.example.credentials
        
        import javax.crypto.Cipher
        import javax.crypto.spec.GCMParameterSpec
        import javax.crypto.spec.SecretKeySpec
        import java.util.Base64
        import java.io.File
        import org.json.JSONObject
        
        enum class CredentialKey {
        """
        
        // Add credential keys
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    \(credential.key),"
        }
        
        code += "\n}\n\n"
        
        // Add CredentialException
        code += """
        class CredentialException(message: String) : Exception(message)
        
        object Credentials {
            private data class EncryptedData(
                val data: ByteArray,
                val nonce: ByteArray,
                val tag: ByteArray
            )
            
            // External key storage
            private var externalKey: SecretKeySpec? = null
            
            // Encrypted credential data
            private val encryptedData = mapOf(
        """
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        CredentialKey.\(credential.key) to EncryptedData("
            code += "\n            data = \(formatKotlinByteArray(credential.encryptedData)),"
            code += "\n            nonce = \(formatKotlinByteArray(credential.nonce)),"
            code += "\n            tag = \(formatKotlinByteArray(credential.tag))"
            code += "\n        ),"
        }
        
        code += "\n    )\n\n"
        
        // Add initialization and decryption methods
        code += """
            // Initialize with raw key data
            @JvmStatic
            fun initialize(keyData: ByteArray) {
                externalKey = SecretKeySpec(keyData, "AES")
            }
            
            // Initialize with base64 encoded key
            @JvmStatic
            fun initialize(base64Key: String) {
                val keyData = Base64.getDecoder().decode(base64Key)
                initialize(keyData)
            }
            
            // Load key from file (supports JSON or plain text)
            @JvmStatic
            fun loadKey(filePath: String) {
                val file = File(filePath)
                val contents = file.readText().trim()
                
                // Try to parse as JSON first
                val base64Key = try {
                    val json = JSONObject(contents)
                    json.getString("key")
                } catch (e: Exception) {
                    // If not JSON, use as plain base64 string
                    contents
                }
                
                initialize(base64Key)
            }
            
            // Check if initialized
            @JvmStatic
            val isInitialized: Boolean
                get() = externalKey != null
            
            // Get decrypted credential
            @JvmStatic
            @Throws(CredentialException::class)
            fun get(key: CredentialKey): String {
                val secretKey = externalKey ?: throw CredentialException("Credentials not initialized. Call initialize() or loadKey() first.")
                val encrypted = encryptedData[key] ?: throw CredentialException("Credential not found: $key")
                
                return try {
                    // Setup cipher for AES-GCM
                    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
                    val gcmSpec = GCMParameterSpec(128, encrypted.nonce)
                    cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec)
                    
                    // Combine ciphertext and tag for decryption
                    val cipherTextWithTag = encrypted.data + encrypted.tag
                    val decrypted = cipher.doFinal(cipherTextWithTag)
                    
                    String(decrypted, Charsets.UTF_8)
                } catch (e: Exception) {
                    throw CredentialException("Failed to decrypt credential: ${e.message}")
                }
            }
            
            // Optional: Get with caching
            private val cache = mutableMapOf<CredentialKey, String>()
            
            @JvmStatic
            @Throws(CredentialException::class)
            fun getCached(key: CredentialKey): String {
                cache[key]?.let { return it }
                
                val decrypted = get(key)
                cache[key] = decrypted
                return decrypted
            }
            
            // Clear cache when needed
            @JvmStatic
            fun clearCache() {
                cache.clear()
            }
        }
        """
        
        return code
    }
    
    private func generateKotlinCodeWithExternalKeySource(credentials: [EncryptedCredential]) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        package com.example.credentials
        
        import javax.crypto.Cipher
        import javax.crypto.spec.GCMParameterSpec
        import javax.crypto.spec.SecretKeySpec
        
        enum class CredentialKey {
        """
        
        // Add credential keys
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    \(credential.key),"
        }
        
        code += "\n}\n\n"
        
        // Add Credentials object
        code += """
        object Credentials {
            private data class EncryptedData(
                val data: ByteArray,
                val nonce: ByteArray,
                val tag: ByteArray
            )
            
            // Encrypted credential data
            private val encryptedData = mapOf(
        """
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        CredentialKey.\(credential.key) to EncryptedData("
            code += "\n            data = \(formatKotlinByteArray(credential.encryptedData)),"
            code += "\n            nonce = \(formatKotlinByteArray(credential.nonce)),"
            code += "\n            tag = \(formatKotlinByteArray(credential.tag))"
            code += "\n        ),"
        }
        
        code += "\n    )\n\n"
        
        // Add decryption using external key source
        code += """
            // Decrypt using key from CredentialKeyProvider
            @JvmStatic
            fun decrypt(key: CredentialKey): String? {
                val encrypted = encryptedData[key] ?: return null
                
                return try {
                    // Get key from external source
                    val secretKey = SecretKeySpec(CredentialKeyProvider.key, "AES")
                    
                    // Setup cipher for AES-GCM
                    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
                    val gcmSpec = GCMParameterSpec(128, encrypted.nonce)
                    cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec)
                    
                    // Combine ciphertext and tag for decryption
                    val cipherTextWithTag = encrypted.data + encrypted.tag
                    val decrypted = cipher.doFinal(cipherTextWithTag)
                    
                    String(decrypted, Charsets.UTF_8)
                } catch (e: Exception) {
                    null
                }
            }
            
            // Optional: Decrypt with caching
            private val cache = mutableMapOf<CredentialKey, String>()
            
            @JvmStatic
            fun decryptCached(key: CredentialKey): String? {
                cache[key]?.let { return it }
                
                val decrypted = decrypt(key) ?: return null
                cache[key] = decrypted
                return decrypted
            }
            
            // Clear cache when needed
            @JvmStatic
            fun clearCache() {
                cache.clear()
            }
        }
        """
        
        return code
    }
    
    func generateWithExternalKey(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Encrypt credentials
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate code with external key support
        return generateKotlinCodeWithExternalKey(credentials: encryptedCredentials)
    }
    
    func generateWithExternalKeySource(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Similar to external key but expects key from source
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        return generateKotlinCodeWithExternalKeySource(credentials: encryptedCredentials)
    }
    
    func generateKeySource(encryptionKey: Data) throws -> String {
        let base64Key = encryptionKey.base64EncodedString()
        
        return """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        package com.example.credentials
        
        import java.util.Base64
        
        object CredentialKeyProvider {
            val key: ByteArray = Base64.getDecoder().decode("\(base64Key)")
        }
        """
    }
}