import Foundation
import CryptoKit

struct PythonCodeGenerator: CodeGenerator {
    let language = "python"
    let defaultFileName = "Generated/credentials.py"
    
    func generate(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Use the provided encryption key as the runtime key
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            // Convert plain text to data
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            // Encrypt with runtime key
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate Python code
        return generatePythonCode(
            credentials: encryptedCredentials,
            runtimeKey: encryptionKey
        )
    }
    
    private func generatePythonCode(credentials: [EncryptedCredential], runtimeKey: Data) -> String {
        var code = """
        # Auto-generated by credential-code
        # DO NOT EDIT - This file will be overwritten
        
        from enum import Enum
        from typing import Optional, Dict
        from cryptography.hazmat.primitives.ciphers.aead import AESGCM
        
        
        class CredentialKey(Enum):
        """
        
        // Add credential keys
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    \(credential.key) = \"\(credential.key)\""
        }
        
        code += "\n\n\n"
        
        // Add Credentials class
        code += """
        class Credentials:
            # Encrypted credential data as byte arrays
            _encrypted_data = {
        """
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        CredentialKey.\(credential.key): {"
            code += "\n            'data': \(formatPythonBytes(credential.encryptedData)),"
            code += "\n            'nonce': \(formatPythonBytes(credential.nonce)),"
            code += "\n            'tag': \(formatPythonBytes(credential.tag))"
            code += "\n        },"
        }
        
        code += "\n    }\n\n"
        
        // Add obfuscated key
        let keyComponents = splitIntoComponents(runtimeKey, componentSize: 4)
        code += "    # Runtime decryption key (obfuscated)\n"
        code += "    _key_components = [\n"
        for component in keyComponents {
            code += "        \(formatPythonBytes(component)),\n"
        }
        code += "    ]\n\n"
        
        // Add decryption methods
        code += """
            # Cache for decrypted values
            _cache: Dict[CredentialKey, str] = {}
            
            @staticmethod
            def decrypt(key: CredentialKey) -> Optional[str]:
                \"\"\"Decrypt a credential by key.\"\"\"
                encrypted = Credentials._encrypted_data.get(key)
                if not encrypted:
                    return None
                
                try:
                    # Reconstruct the decryption key
                    key_data = b''.join(Credentials._key_components)
                    
                    # Decrypt using AES-GCM
                    aesgcm = AESGCM(key_data)
                    decrypted = aesgcm.decrypt(
                        encrypted['nonce'],
                        encrypted['data'] + encrypted['tag'],
                        None
                    )
                    
                    return decrypted.decode('utf-8')
                except Exception:
                    return None
            
            @staticmethod
            def decrypt_cached(key: CredentialKey) -> Optional[str]:
                \"\"\"Decrypt a credential with caching.\"\"\"
                if key in Credentials._cache:
                    return Credentials._cache[key]
                
                decrypted = Credentials.decrypt(key)
                if decrypted:
                    Credentials._cache[key] = decrypted
                return decrypted
            
            @staticmethod
            def clear_cache() -> None:
                \"\"\"Clear the credential cache.\"\"\"
                Credentials._cache.clear()
        
        
        # Convenience function
        def get_credential(key: CredentialKey) -> Optional[str]:
            \"\"\"Get a credential value by key.\"\"\"
            return Credentials.decrypt(key)
        """
        
        return code
    }
    
    private func formatPythonBytes(_ data: Data) -> String {
        let bytes = data.map { String(format: "\\x%02x", $0) }
        
        // Format as single line if short
        if data.count <= 16 {
            return "b'" + bytes.joined() + "'"
        }
        
        // Format as multiple lines if long
        var result = "(\n                b'"
        for (index, byte) in bytes.enumerated() {
            if index > 0 && index % 16 == 0 {
                result += "'\n                b'"
            }
            result += byte
        }
        result += "'\n            )"
        return result
    }
    
    private func splitIntoComponents(_ data: Data, componentSize: Int) -> [Data] {
        var components: [Data] = []
        var offset = 0
        
        while offset < data.count {
            let remainingBytes = data.count - offset
            let size = min(componentSize, remainingBytes)
            components.append(data.subdata(in: offset..<(offset + size)))
            offset += size
        }
        
        return components
    }
}