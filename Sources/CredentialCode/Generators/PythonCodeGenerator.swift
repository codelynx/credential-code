import Foundation
import CryptoKit

struct PythonCodeGenerator: CodeGenerator {
    let language = "python"
    let defaultFileName = "Generated/credentials.py"
    
    func generate(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Use the provided encryption key as the runtime key
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            // Convert plain text to data
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            // Encrypt with runtime key
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate Python code
        return generatePythonCode(
            credentials: encryptedCredentials,
            runtimeKey: encryptionKey
        )
    }
    
    private func generatePythonCode(credentials: [EncryptedCredential], runtimeKey: Data) -> String {
        var code = """
        # Auto-generated by credential-code
        # DO NOT EDIT - This file will be overwritten
        
        from enum import Enum
        from typing import Optional, Dict
        from cryptography.hazmat.primitives.ciphers.aead import AESGCM
        
        
        class CredentialKey(Enum):
        """
        
        // Add credential keys
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    \(credential.key) = \"\(credential.key)\""
        }
        
        code += "\n\n\n"
        
        // Add Credentials class
        code += """
        class Credentials:
            # Encrypted credential data as byte arrays
            _encrypted_data = {
        """
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        CredentialKey.\(credential.key): {"
            code += "\n            'data': \(formatPythonBytes(credential.encryptedData)),"
            code += "\n            'nonce': \(formatPythonBytes(credential.nonce)),"
            code += "\n            'tag': \(formatPythonBytes(credential.tag))"
            code += "\n        },"
        }
        
        code += "\n    }\n\n"
        
        // Add obfuscated key
        let keyComponents = splitIntoComponents(runtimeKey, componentSize: 4)
        code += "    # Runtime decryption key (obfuscated)\n"
        code += "    _key_components = [\n"
        for component in keyComponents {
            code += "        \(formatPythonBytes(component)),\n"
        }
        code += "    ]\n\n"
        
        // Add decryption methods
        code += """
            # Cache for decrypted values
            _cache: Dict[CredentialKey, str] = {}
            
            @staticmethod
            def decrypt(key: CredentialKey) -> Optional[str]:
                \"\"\"Decrypt a credential by key.\"\"\"
                encrypted = Credentials._encrypted_data.get(key)
                if not encrypted:
                    return None
                
                try:
                    # Reconstruct the decryption key
                    key_data = b''.join(Credentials._key_components)
                    
                    # Decrypt using AES-GCM
                    aesgcm = AESGCM(key_data)
                    decrypted = aesgcm.decrypt(
                        encrypted['nonce'],
                        encrypted['data'] + encrypted['tag'],
                        None
                    )
                    
                    return decrypted.decode('utf-8')
                except Exception:
                    return None
            
            @staticmethod
            def decrypt_cached(key: CredentialKey) -> Optional[str]:
                \"\"\"Decrypt a credential with caching.\"\"\"
                if key in Credentials._cache:
                    return Credentials._cache[key]
                
                decrypted = Credentials.decrypt(key)
                if decrypted:
                    Credentials._cache[key] = decrypted
                return decrypted
            
            @staticmethod
            def clear_cache() -> None:
                \\\"\\\"\\\"Clear the credential cache.\\\"\\\"\\\"
                Credentials._cache.clear()
        
        
        # Convenience function
        def get_credential(key: CredentialKey) -> Optional[str]:
            \"\"\"Get a credential value by key.\"\"\"
            return Credentials.decrypt(key)
        """
        
        return code
    }
    
    private func formatPythonBytes(_ data: Data) -> String {
        let bytes = data.map { String(format: "\\x%02x", $0) }
        
        // Format as single line if short
        if data.count <= 16 {
            return "b'" + bytes.joined() + "'"
        }
        
        // Format as multiple lines if long
        var result = "(\n                b'"
        for (index, byte) in bytes.enumerated() {
            if index > 0 && index % 16 == 0 {
                result += "'\n                b'"
            }
            result += byte
        }
        result += "'\n            )"
        return result
    }
    
    private func splitIntoComponents(_ data: Data, componentSize: Int) -> [Data] {
        var components: [Data] = []
        var offset = 0
        
        while offset < data.count {
            let remainingBytes = data.count - offset
            let size = min(componentSize, remainingBytes)
            components.append(data.subdata(in: offset..<(offset + size)))
            offset += size
        }
        
        return components
    }
    
    private func generatePythonCodeWithExternalKey(credentials: [EncryptedCredential]) -> String {
        var code = """
# Auto-generated by credential-code
# DO NOT EDIT - This file will be overwritten

from enum import Enum
from typing import Optional, Dict, Union
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import base64
import json


class CredentialError(Exception):
    \"\"\"Exception raised for credential-related errors.\"\"\"
    pass


class CredentialKey(Enum):
"""
        
        // Add credential keys
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    \(credential.key) = \"\(credential.key)\""
        }
        
        code += "\n\n\n"
        
        // Add Credentials class
        code += """
class Credentials:
    # External key storage
    _external_key: Optional[bytes] = None
    
    # Encrypted credential data
    _encrypted_data = {
"""
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        CredentialKey.\(credential.key): {"
            code += "\n            'data': \(formatPythonBytes(credential.encryptedData)),"
            code += "\n            'nonce': \(formatPythonBytes(credential.nonce)),"
            code += "\n            'tag': \(formatPythonBytes(credential.tag))"
            code += "\n        },"
        }
        
        code += "\n    }\n\n"
        
        // Add initialization and decryption methods
        code += """
    # Cache for decrypted values
    _cache: Dict[CredentialKey, str] = {}
    
    @staticmethod
    def initialize(key_data: bytes) -> None:
        \"\"\"Initialize with raw key data.\"\"\"
        Credentials._external_key = key_data
    
    @staticmethod
    def initialize_base64(base64_key: str) -> None:
        \"\"\"Initialize with base64 encoded key.\"\"\"
        key_data = base64.b64decode(base64_key)
        Credentials.initialize(key_data)
    
    @staticmethod
    def load_key(file_path: str) -> None:
        \"\"\"Load key from file (JSON or plain text).\"\"\"
        with open(file_path, 'r') as f:
            contents = f.read().strip()
        
        # Try JSON first
        try:
            data = json.loads(contents)
            base64_key = data['key']
        except (json.JSONDecodeError, KeyError):
            # If not JSON, use as plain base64 string
            base64_key = contents
        
        Credentials.initialize_base64(base64_key)
    
    @staticmethod
    def is_initialized() -> bool:
        \"\"\"Check if credentials are initialized.\"\"\"
        return Credentials._external_key is not None
    
    @staticmethod
    def get(key: CredentialKey) -> str:
        \"\"\"Get decrypted credential.\"\"\"
        if Credentials._external_key is None:
            raise CredentialError("Credentials not initialized. Call initialize() or load_key() first.")
        
        encrypted = Credentials._encrypted_data.get(key)
        if not encrypted:
            raise CredentialError(f"Credential not found: {key}")
        
        try:
            # Decrypt using AES-GCM
            aesgcm = AESGCM(Credentials._external_key)
            decrypted = aesgcm.decrypt(
                encrypted['nonce'],
                encrypted['data'] + encrypted['tag'],
                None
            )
            
            return decrypted.decode('utf-8')
        except Exception as e:
            raise CredentialError(f"Failed to decrypt credential: {str(e)}")
    
    @staticmethod
    def get_cached(key: CredentialKey) -> str:
        \"\"\"Get credential with caching.\"\"\"
        if key in Credentials._cache:
            return Credentials._cache[key]
        
        decrypted = Credentials.get(key)
        Credentials._cache[key] = decrypted
        return decrypted
    
    @staticmethod
    def clear_cache() -> None:
        \"\"\"Clear the credential cache.\"\"\"
        Credentials._cache.clear()


# Convenience functions
def initialize(key: Union[bytes, str]) -> None:
    \"\"\"Initialize credentials with key.\"\"\"
    if isinstance(key, bytes):
        Credentials.initialize(key)
    else:
        Credentials.initialize_base64(key)

def load_key(file_path: str) -> None:
    \"\"\"Load encryption key from file.\"\"\"
    Credentials.load_key(file_path)

def get_credential(key: CredentialKey) -> str:
    \"\"\"Get a credential value by key.\"\"\"
    return Credentials.get(key)
"""
        
        return code
    }
    
    private func generatePythonCodeWithExternalKeySource(credentials: [EncryptedCredential]) -> String {
        var code = """
# Auto-generated by credential-code
# DO NOT EDIT - This file will be overwritten

from enum import Enum
from typing import Optional, Dict
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import credential_key


class CredentialKey(Enum):
"""
        
        // Add credential keys
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    \(credential.key) = \"\(credential.key)\""
        }
        
        code += "\n\n\n"
        
        // Add Credentials class
        code += """
class Credentials:
    # Encrypted credential data
    _encrypted_data = {
"""
        
        // Add encrypted data
        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        CredentialKey.\(credential.key): {"
            code += "\n            'data': \(formatPythonBytes(credential.encryptedData)),"
            code += "\n            'nonce': \(formatPythonBytes(credential.nonce)),"
            code += "\n            'tag': \(formatPythonBytes(credential.tag))"
            code += "\n        },"
        }
        
        code += "\n    }\n\n"
        
        // Add decryption methods using external key source
        code += """
    # Cache for decrypted values
    _cache: Dict[CredentialKey, str] = {}
    
    @staticmethod
    def decrypt(key: CredentialKey) -> Optional[str]:
        \"\"\"Decrypt a credential by key.\"\"\"
        encrypted = Credentials._encrypted_data.get(key)
        if not encrypted:
            return None
        
        try:
            # Get key from external source
            aesgcm = AESGCM(credential_key.key)
            decrypted = aesgcm.decrypt(
                encrypted['nonce'],
                encrypted['data'] + encrypted['tag'],
                None
            )
            
            return decrypted.decode('utf-8')
        except Exception:
            return None
    
    @staticmethod
    def decrypt_cached(key: CredentialKey) -> Optional[str]:
        \"\"\"Decrypt a credential with caching.\"\"\"
        if key in Credentials._cache:
            return Credentials._cache[key]
        
        decrypted = Credentials.decrypt(key)
        if decrypted:
            Credentials._cache[key] = decrypted
        return decrypted
    
    @staticmethod
    def clear_cache() -> None:
        \"\"\"Clear the credential cache.\"\"\"
        Credentials._cache.clear()


# Convenience function
def get_credential(key: CredentialKey) -> Optional[str]:
    \"\"\"Get a credential value by key.\"\"\"
    return Credentials.decrypt(key)
"""
        
        return code
    }
    
    func generateWithExternalKey(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Encrypt credentials
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate code with external key support
        return generatePythonCodeWithExternalKey(credentials: encryptedCredentials)
    }
    
    func generateWithExternalKeySource(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Similar to external key but expects key from source
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        return generatePythonCodeWithExternalKeySource(credentials: encryptedCredentials)
    }
    
    func generateKeySource(encryptionKey: Data) throws -> String {
        let base64Key = encryptionKey.base64EncodedString()
        
        return """
        # Auto-generated by credential-code
        # DO NOT EDIT - This file will be overwritten
        
        import base64
        
        # Encryption key for credentials
        key = base64.b64decode("\(base64Key)")
        """
    }
}