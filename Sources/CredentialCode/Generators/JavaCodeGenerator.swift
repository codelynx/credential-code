import Foundation
import CryptoKit

struct JavaCodeGenerator: CodeGenerator {
    let language = "java"
    let defaultFileName = "Generated/Credentials.java"
    
    func generate(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Use the provided encryption key as the runtime key
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            // Convert plain text to data
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            // Encrypt with runtime key
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate Java code
        return generateJavaCode(
            credentials: encryptedCredentials,
            runtimeKey: encryptionKey
        )
    }
    
    private func generateJavaCode(credentials: [EncryptedCredential], runtimeKey: Data) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        package com.example.credentials;
        
        import javax.crypto.Cipher;
        import javax.crypto.spec.GCMParameterSpec;
        import javax.crypto.spec.SecretKeySpec;
        import java.nio.charset.StandardCharsets;
        import java.util.Arrays;
        import java.util.HashMap;
        import java.util.Map;
        
        public final class Credentials {
            public enum CredentialKey {
        """
        
        // Add credential keys
        let sortedCredentials = credentials.sorted(by: { $0.key < $1.key })
        for (index, credential) in sortedCredentials.enumerated() {
            code += "\n        \(credential.key)"
            if index < sortedCredentials.count - 1 {
                code += ","
            }
        }
        
        code += "\n    }\n\n"
        
        // Add EncryptedData class
        code += """
            private static class EncryptedData {
                final byte[] data;
                final byte[] nonce;
                final byte[] tag;
                
                EncryptedData(byte[] data, byte[] nonce, byte[] tag) {
                    this.data = data;
                    this.nonce = nonce;
                    this.tag = tag;
                }
            }
            
            private static final Map<CredentialKey, EncryptedData> encryptedData;
            private static final byte[][] keyComponents;
            
            static {
                // Initialize encrypted data
                encryptedData = new HashMap<>();
        """
        
        // Add encrypted data initialization
        for credential in sortedCredentials {
            code += "\n        encryptedData.put(CredentialKey.\(credential.key), new EncryptedData("
            code += "\n            \(formatJavaByteArray(credential.encryptedData)),"
            code += "\n            \(formatJavaByteArray(credential.nonce)),"
            code += "\n            \(formatJavaByteArray(credential.tag))"
            code += "\n        ));"
        }
        
        code += "\n\n        // Initialize key components\n"
        let keyComponents = splitIntoComponents(runtimeKey, componentSize: 4)
        code += "        keyComponents = new byte[][]{\n"
        for component in keyComponents {
            code += "            \(formatJavaByteArray(component)),\n"
        }
        code += "        };\n    }\n\n"
        
        // Add decryption methods
        code += """
            public static String decrypt(CredentialKey key) {
                EncryptedData encrypted = encryptedData.get(key);
                if (encrypted == null) return null;
                
                try {
                    // Reconstruct key
                    byte[] keyData = reconstructKey();
                    SecretKeySpec secretKey = new SecretKeySpec(keyData, "AES");
                    
                    // Decrypt
                    Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
                    GCMParameterSpec gcmSpec = new GCMParameterSpec(128, encrypted.nonce);
                    cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec);
                    
                    byte[] combined = concatenate(encrypted.data, encrypted.tag);
                    byte[] decrypted = cipher.doFinal(combined);
                    
                    return new String(decrypted, StandardCharsets.UTF_8);
                } catch (Exception e) {
                    return null;
                }
            }
            
            private static byte[] reconstructKey() {
                int totalLength = 0;
                for (byte[] component : keyComponents) {
                    totalLength += component.length;
                }
                
                byte[] result = new byte[totalLength];
                int offset = 0;
                for (byte[] component : keyComponents) {
                    System.arraycopy(component, 0, result, offset, component.length);
                    offset += component.length;
                }
                return result;
            }
            
            private static byte[] concatenate(byte[] a, byte[] b) {
                byte[] result = new byte[a.length + b.length];
                System.arraycopy(a, 0, result, 0, a.length);
                System.arraycopy(b, 0, result, a.length, b.length);
                return result;
            }
            
            // Optional: Cached decryption
            private static final Map<CredentialKey, String> cache = new HashMap<>();
            
            public static String decryptCached(CredentialKey key) {
                String cached = cache.get(key);
                if (cached != null) return cached;
                
                String decrypted = decrypt(key);
                if (decrypted != null) {
                    cache.put(key, decrypted);
                }
                return decrypted;
            }
            
            public static void clearCache() {
                cache.clear();
            }
        }
        """
        
        return code
    }
    
    private func formatJavaByteArray(_ data: Data) -> String {
        let bytes = data.map { byte in
            let value = Int8(bitPattern: byte)
            return value < 0 ? "(byte)\(value)" : "(byte)0x\(String(format: "%02X", byte))"
        }
        
        // Format as single line if short
        if bytes.count <= 6 {
            return "new byte[]{" + bytes.joined(separator: ", ") + "}"
        }
        
        // Format as multiple lines if long
        var result = "new byte[]{\n                "
        for (index, byte) in bytes.enumerated() {
            if index > 0 && index % 6 == 0 {
                result += ",\n                "
            } else if index > 0 {
                result += ", "
            }
            result += byte
        }
        result += "\n            }"
        return result
    }
    
    private func splitIntoComponents(_ data: Data, componentSize: Int) -> [Data] {
        var components: [Data] = []
        var offset = 0
        
        while offset < data.count {
            let remainingBytes = data.count - offset
            let size = min(componentSize, remainingBytes)
            components.append(data.subdata(in: offset..<(offset + size)))
            offset += size
        }
        
        return components
    }
    
    private func generateJavaCodeWithExternalKey(credentials: [EncryptedCredential]) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        package com.example.credentials;
        
        import javax.crypto.Cipher;
        import javax.crypto.spec.GCMParameterSpec;
        import javax.crypto.spec.SecretKeySpec;
        import java.nio.charset.StandardCharsets;
        import java.util.Arrays;
        import java.util.Base64;
        import java.util.HashMap;
        import java.util.Map;
        import java.io.IOException;
        import java.nio.file.Files;
        import java.nio.file.Paths;
        import com.fasterxml.jackson.databind.ObjectMapper;
        import com.fasterxml.jackson.databind.JsonNode;
        
        public final class Credentials {
            public enum CredentialKey {
        """
        
        // Add credential keys
        let sortedCredentials = credentials.sorted(by: { $0.key < $1.key })
        for (index, credential) in sortedCredentials.enumerated() {
            code += "\n        \(credential.key)"
            if index < sortedCredentials.count - 1 {
                code += ","
            }
        }
        
        code += "\n    }\n\n"
        
        // Add exception and data classes
        code += """
            public static class CredentialException extends Exception {
                public CredentialException(String message) {
                    super(message);
                }
            }
            
            private static class EncryptedData {
                final byte[] data;
                final byte[] nonce;
                final byte[] tag;
                
                EncryptedData(byte[] data, byte[] nonce, byte[] tag) {
                    this.data = data;
                    this.nonce = nonce;
                    this.tag = tag;
                }
            }
            
            private static final Map<CredentialKey, EncryptedData> encryptedData;
            private static SecretKeySpec externalKey = null;
            
            static {
                // Initialize encrypted data
                encryptedData = new HashMap<>();
        """
        
        // Add encrypted data initialization
        for credential in sortedCredentials {
            code += "\n        encryptedData.put(CredentialKey.\(credential.key), new EncryptedData("
            code += "\n            \(formatJavaByteArray(credential.encryptedData)),"
            code += "\n            \(formatJavaByteArray(credential.nonce)),"
            code += "\n            \(formatJavaByteArray(credential.tag))"
            code += "\n        ));"
        }
        
        code += "\n    }\n\n"
        
        // Add initialization and decryption methods
        code += """
            // Initialize with raw key data
            public static void initialize(byte[] keyData) {
                externalKey = new SecretKeySpec(keyData, "AES");
            }
            
            // Initialize with base64 encoded key
            public static void initialize(String base64Key) throws Exception {
                byte[] keyData = Base64.getDecoder().decode(base64Key);
                initialize(keyData);
            }
            
            // Load key from file (supports JSON or plain text)
            public static void loadKey(String filePath) throws IOException {
                String contents = new String(Files.readAllBytes(Paths.get(filePath))).trim();
                String base64Key;
                
                // Try to parse as JSON first
                try {
                    ObjectMapper mapper = new ObjectMapper();
                    JsonNode root = mapper.readTree(contents);
                    base64Key = root.get("key").asText();
                } catch (Exception e) {
                    // If not JSON, use as plain base64 string
                    base64Key = contents;
                }
                
                try {
                    initialize(base64Key);
                } catch (Exception e) {
                    throw new IOException("Failed to initialize key: " + e.getMessage());
                }
            }
            
            // Check if initialized
            public static boolean isInitialized() {
                return externalKey != null;
            }
            
            // Get decrypted credential
            public static String get(CredentialKey key) throws CredentialException {
                if (externalKey == null) {
                    throw new CredentialException("Credentials not initialized. Call initialize() or loadKey() first.");
                }
                
                EncryptedData encrypted = encryptedData.get(key);
                if (encrypted == null) {
                    throw new CredentialException("Credential not found: " + key);
                }
                
                try {
                    // Decrypt
                    Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
                    GCMParameterSpec gcmSpec = new GCMParameterSpec(128, encrypted.nonce);
                    cipher.init(Cipher.DECRYPT_MODE, externalKey, gcmSpec);
                    
                    byte[] combined = concatenate(encrypted.data, encrypted.tag);
                    byte[] decrypted = cipher.doFinal(combined);
                    
                    return new String(decrypted, StandardCharsets.UTF_8);
                } catch (Exception e) {
                    throw new CredentialException("Failed to decrypt credential: " + e.getMessage());
                }
            }
            
            private static byte[] concatenate(byte[] a, byte[] b) {
                byte[] result = new byte[a.length + b.length];
                System.arraycopy(a, 0, result, 0, a.length);
                System.arraycopy(b, 0, result, a.length, b.length);
                return result;
            }
            
            // Optional: Cached decryption
            private static final Map<CredentialKey, String> cache = new HashMap<>();
            
            public static String getCached(CredentialKey key) throws CredentialException {
                String cached = cache.get(key);
                if (cached != null) return cached;
                
                String decrypted = get(key);
                cache.put(key, decrypted);
                return decrypted;
            }
            
            public static void clearCache() {
                cache.clear();
            }
        }
        """
        
        return code
    }
    
    private func generateJavaCodeWithExternalKeySource(credentials: [EncryptedCredential]) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        package com.example.credentials;
        
        import javax.crypto.Cipher;
        import javax.crypto.spec.GCMParameterSpec;
        import javax.crypto.spec.SecretKeySpec;
        import java.nio.charset.StandardCharsets;
        import java.util.Arrays;
        import java.util.HashMap;
        import java.util.Map;
        
        public final class Credentials {
            public enum CredentialKey {
        """
        
        // Add credential keys
        let sortedCredentials = credentials.sorted(by: { $0.key < $1.key })
        for (index, credential) in sortedCredentials.enumerated() {
            code += "\n        \(credential.key)"
            if index < sortedCredentials.count - 1 {
                code += ","
            }
        }
        
        code += "\n    }\n\n"
        
        // Add data classes
        code += """
            private static class EncryptedData {
                final byte[] data;
                final byte[] nonce;
                final byte[] tag;
                
                EncryptedData(byte[] data, byte[] nonce, byte[] tag) {
                    this.data = data;
                    this.nonce = nonce;
                    this.tag = tag;
                }
            }
            
            private static final Map<CredentialKey, EncryptedData> encryptedData;
            
            static {
                // Initialize encrypted data
                encryptedData = new HashMap<>();
        """
        
        // Add encrypted data initialization
        for credential in sortedCredentials {
            code += "\n        encryptedData.put(CredentialKey.\(credential.key), new EncryptedData("
            code += "\n            \(formatJavaByteArray(credential.encryptedData)),"
            code += "\n            \(formatJavaByteArray(credential.nonce)),"
            code += "\n            \(formatJavaByteArray(credential.tag))"
            code += "\n        ));"
        }
        
        code += "\n    }\n\n"
        
        // Add decryption methods using external key source
        code += """
            // Decrypt using key from CredentialKeyProvider
            public static String decrypt(CredentialKey key) {
                EncryptedData encrypted = encryptedData.get(key);
                if (encrypted == null) return null;
                
                try {
                    // Get key from external source
                    SecretKeySpec secretKey = new SecretKeySpec(CredentialKeyProvider.key, "AES");
                    
                    // Decrypt
                    Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
                    GCMParameterSpec gcmSpec = new GCMParameterSpec(128, encrypted.nonce);
                    cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec);
                    
                    byte[] combined = concatenate(encrypted.data, encrypted.tag);
                    byte[] decrypted = cipher.doFinal(combined);
                    
                    return new String(decrypted, StandardCharsets.UTF_8);
                } catch (Exception e) {
                    return null;
                }
            }
            
            private static byte[] concatenate(byte[] a, byte[] b) {
                byte[] result = new byte[a.length + b.length];
                System.arraycopy(a, 0, result, 0, a.length);
                System.arraycopy(b, 0, result, a.length, b.length);
                return result;
            }
            
            // Optional: Cached decryption
            private static final Map<CredentialKey, String> cache = new HashMap<>();
            
            public static String decryptCached(CredentialKey key) {
                String cached = cache.get(key);
                if (cached != null) return cached;
                
                String decrypted = decrypt(key);
                if (decrypted != null) {
                    cache.put(key, decrypted);
                }
                return decrypted;
            }
            
            public static void clearCache() {
                cache.clear();
            }
        }
        """
        
        return code
    }
    
    func generateWithExternalKey(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Encrypt credentials
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        // Generate code with external key support
        return generateJavaCodeWithExternalKey(credentials: encryptedCredentials)
    }
    
    func generateWithExternalKeySource(credentials: [String: String], encryptionKey: Data) throws -> String {
        // Similar to external key but expects key from source
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, plainValue) in credentials {
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }
            
            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }
        
        return generateJavaCodeWithExternalKeySource(credentials: encryptedCredentials)
    }
    
    func generateKeySource(encryptionKey: Data) throws -> String {
        let base64Key = encryptionKey.base64EncodedString()
        
        return """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        package com.example.credentials;
        
        import java.util.Base64;
        
        public final class CredentialKeyProvider {
            public static final byte[] key = Base64.getDecoder().decode("\(base64Key)");
        }
        """
    }
}