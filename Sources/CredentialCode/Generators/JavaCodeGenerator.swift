import Foundation
import CryptoKit

struct JavaCodeGenerator: CodeGenerator {
    let language = "java"
    let defaultFileName = "Generated/Credentials.java"
    
    func generate(credentials: [String: String], encryptionKey: Data) throws -> String {
        // First, decrypt and re-encrypt all credentials with a new runtime key
        let runtimeKey = SymmetricKey(size: .bits256)
        var encryptedCredentials: [EncryptedCredential] = []
        
        for (key, encryptedValue) in credentials {
            // Decode the stored encrypted value
            guard let combinedData = Data(base64Encoded: encryptedValue) else {
                throw CredentialError.invalidEncryptedData
            }
            
            // Extract nonce (12 bytes), ciphertext, and tag (16 bytes)
            let nonceSize = 12
            let tagSize = 16
            
            guard combinedData.count > nonceSize + tagSize else {
                throw CredentialError.invalidEncryptedData
            }
            
            let nonce = combinedData.prefix(nonceSize)
            let ciphertext = combinedData.dropFirst(nonceSize).dropLast(tagSize)
            let tag = combinedData.suffix(tagSize)
            
            // Decrypt with storage key
            let storageKey = SymmetricKey(data: encryptionKey)
            let sealedBox = try AES.GCM.SealedBox(
                nonce: AES.GCM.Nonce(data: nonce),
                ciphertext: ciphertext,
                tag: tag
            )
            let plaintext = try AES.GCM.open(sealedBox, using: storageKey)
            
            // Re-encrypt with runtime key
            let newSealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)
            
            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: newSealedBox.ciphertext,
                nonce: newSealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: newSealedBox.tag
            ))
        }
        
        // Generate Java code
        return generateJavaCode(
            credentials: encryptedCredentials,
            runtimeKey: runtimeKey.withUnsafeBytes { Data($0) }
        )
    }
    
    private func generateJavaCode(credentials: [EncryptedCredential], runtimeKey: Data) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten
        
        package com.example.credentials;
        
        import javax.crypto.Cipher;
        import javax.crypto.spec.GCMParameterSpec;
        import javax.crypto.spec.SecretKeySpec;
        import java.nio.charset.StandardCharsets;
        import java.util.Arrays;
        import java.util.HashMap;
        import java.util.Map;
        
        public final class Credentials {
            public enum CredentialKey {
        """
        
        // Add credential keys
        let sortedCredentials = credentials.sorted(by: { $0.key < $1.key })
        for (index, credential) in sortedCredentials.enumerated() {
            code += "\n        \(credential.key)"
            if index < sortedCredentials.count - 1 {
                code += ","
            }
        }
        
        code += "\n    }\n\n"
        
        // Add EncryptedData class
        code += """
            private static class EncryptedData {
                final byte[] data;
                final byte[] nonce;
                final byte[] tag;
                
                EncryptedData(byte[] data, byte[] nonce, byte[] tag) {
                    this.data = data;
                    this.nonce = nonce;
                    this.tag = tag;
                }
            }
            
            private static final Map<CredentialKey, EncryptedData> encryptedData;
            private static final byte[][] keyComponents;
            
            static {
                // Initialize encrypted data
                encryptedData = new HashMap<>();
        """
        
        // Add encrypted data initialization
        for credential in sortedCredentials {
            code += "\n        encryptedData.put(CredentialKey.\(credential.key), new EncryptedData("
            code += "\n            \(formatJavaByteArray(credential.encryptedData)),"
            code += "\n            \(formatJavaByteArray(credential.nonce)),"
            code += "\n            \(formatJavaByteArray(credential.tag))"
            code += "\n        ));"
        }
        
        code += "\n\n        // Initialize key components\n"
        let keyComponents = splitIntoComponents(runtimeKey, componentSize: 4)
        code += "        keyComponents = new byte[][]{\n"
        for component in keyComponents {
            code += "            \(formatJavaByteArray(component)),\n"
        }
        code += "        };\n    }\n\n"
        
        // Add decryption methods
        code += """
            public static String decrypt(CredentialKey key) {
                EncryptedData encrypted = encryptedData.get(key);
                if (encrypted == null) return null;
                
                try {
                    // Reconstruct key
                    byte[] keyData = reconstructKey();
                    SecretKeySpec secretKey = new SecretKeySpec(keyData, "AES");
                    
                    // Decrypt
                    Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
                    GCMParameterSpec gcmSpec = new GCMParameterSpec(128, encrypted.nonce);
                    cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec);
                    
                    byte[] combined = concatenate(encrypted.data, encrypted.tag);
                    byte[] decrypted = cipher.doFinal(combined);
                    
                    return new String(decrypted, StandardCharsets.UTF_8);
                } catch (Exception e) {
                    return null;
                }
            }
            
            private static byte[] reconstructKey() {
                int totalLength = 0;
                for (byte[] component : keyComponents) {
                    totalLength += component.length;
                }
                
                byte[] result = new byte[totalLength];
                int offset = 0;
                for (byte[] component : keyComponents) {
                    System.arraycopy(component, 0, result, offset, component.length);
                    offset += component.length;
                }
                return result;
            }
            
            private static byte[] concatenate(byte[] a, byte[] b) {
                byte[] result = new byte[a.length + b.length];
                System.arraycopy(a, 0, result, 0, a.length);
                System.arraycopy(b, 0, result, a.length, b.length);
                return result;
            }
            
            // Optional: Cached decryption
            private static final Map<CredentialKey, String> cache = new HashMap<>();
            
            public static String decryptCached(CredentialKey key) {
                String cached = cache.get(key);
                if (cached != null) return cached;
                
                String decrypted = decrypt(key);
                if (decrypted != null) {
                    cache.put(key, decrypted);
                }
                return decrypted;
            }
            
            public static void clearCache() {
                cache.clear();
            }
        }
        """
        
        return code
    }
    
    private func formatJavaByteArray(_ data: Data) -> String {
        let bytes = data.map { byte in
            let value = Int8(bitPattern: byte)
            return value < 0 ? "(byte)\(value)" : "(byte)0x\(String(format: "%02X", byte))"
        }
        
        // Format as single line if short
        if bytes.count <= 6 {
            return "new byte[]{" + bytes.joined(separator: ", ") + "}"
        }
        
        // Format as multiple lines if long
        var result = "new byte[]{\n                "
        for (index, byte) in bytes.enumerated() {
            if index > 0 && index % 6 == 0 {
                result += ",\n                "
            } else if index > 0 {
                result += ", "
            }
            result += byte
        }
        result += "\n            }"
        return result
    }
    
    private func splitIntoComponents(_ data: Data, componentSize: Int) -> [Data] {
        var components: [Data] = []
        var offset = 0
        
        while offset < data.count {
            let remainingBytes = data.count - offset
            let size = min(componentSize, remainingBytes)
            components.append(data.subdata(in: offset..<(offset + size)))
            offset += size
        }
        
        return components
    }
}