import Foundation
import CryptoKit

public struct KotlinCodeGenerator: CodeGenerator {
    public let language = "kotlin"
    public let defaultFileName = "Generated/Credentials.kt"

    public init() {}

    public func generate(credentials: [String: String], encryptionKey: Data) throws -> String {
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []

        for (key, plainValue) in credentials {
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }

            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)

            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }

        return generateKotlinCode(
            credentials: encryptedCredentials,
            runtimeKey: encryptionKey
        )
    }

    private func generateKotlinCode(credentials: [EncryptedCredential], runtimeKey: Data) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten

        package com.example.credentials

        import javax.crypto.Cipher
        import javax.crypto.spec.GCMParameterSpec
        import javax.crypto.spec.SecretKeySpec

        enum class CredentialKey {
        """

        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    \(credential.key),"
        }

        code += "\n}\n\n"

        code += """
        object Credentials {
            private data class EncryptedData(
                val data: ByteArray,
                val nonce: ByteArray,
                val tag: ByteArray
            )

            // Encrypted credential data as byte arrays
            private val encryptedData = mapOf(
        """

        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        CredentialKey.\(credential.key) to EncryptedData("
            code += "\n            data = \(formatKotlinByteArray(credential.encryptedData)),"
            code += "\n            nonce = \(formatKotlinByteArray(credential.nonce)),"
            code += "\n            tag = \(formatKotlinByteArray(credential.tag))"
            code += "\n        ),"
        }

        code += "\n    )\n\n"

        let keyComponents = splitIntoComponents(runtimeKey, componentSize: 4)
        code += "    // Runtime decryption key (obfuscated)\n"
        code += "    private val keyComponents = arrayOf(\n"
        for component in keyComponents {
            code += "        \(formatKotlinByteArray(component)),\n"
        }
        code += "    )\n\n"

        code += """
            @JvmStatic
            fun decrypt(key: CredentialKey): String? {
                val encrypted = encryptedData[key] ?: return null

                return try {
                    // Reconstruct the decryption key
                    val keyData = keyComponents.flatMap { it.toList() }.toByteArray()
                    val secretKey = SecretKeySpec(keyData, "AES")

                    // Setup cipher for AES-GCM
                    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
                    val gcmSpec = GCMParameterSpec(128, encrypted.nonce)
                    cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec)

                    // Combine ciphertext and tag for decryption
                    val cipherTextWithTag = encrypted.data + encrypted.tag
                    val decrypted = cipher.doFinal(cipherTextWithTag)

                    String(decrypted, Charsets.UTF_8)
                } catch (e: Exception) {
                    null
                }
            }

            // Optional: Decrypt with caching
            private val cache = mutableMapOf<CredentialKey, String>()

            @JvmStatic
            fun decryptCached(key: CredentialKey): String? {
                cache[key]?.let { return it }

                val decrypted = decrypt(key) ?: return null
                cache[key] = decrypted
                return decrypted
            }

            // Clear cache when needed
            @JvmStatic
            fun clearCache() {
                cache.clear()
            }
        }
        """

        return code
    }

    private func formatKotlinByteArray(_ data: Data) -> String {
        let bytes = data.map { byte in
            let value = Int8(bitPattern: byte)
            return value < 0 ? "\(value)" : "0x\(String(format: "%02X", byte))"
        }

        if bytes.count <= 8 {
            return "byteArrayOf(" + bytes.joined(separator: ", ") + ")"
        }

        var result = "byteArrayOf(\n                "
        for (index, byte) in bytes.enumerated() {
            if index > 0 && index % 8 == 0 {
                result += ",\n                "
            } else if index > 0 {
                result += ", "
            }
            result += byte
        }
        result += "\n            )"
        return result
    }

    private func splitIntoComponents(_ data: Data, componentSize: Int) -> [Data] {
        var components: [Data] = []
        var offset = 0

        while offset < data.count {
            let remainingBytes = data.count - offset
            let size = min(componentSize, remainingBytes)
            components.append(data.subdata(in: offset..<(offset + size)))
            offset += size
        }

        return components
    }

    public func generateWithExternalKey(credentials: [String: String], encryptionKey: Data) throws -> String {
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []

        for (key, plainValue) in credentials {
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }

            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)

            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }

        return generateKotlinCodeWithExternalKey(credentials: encryptedCredentials)
    }

    private func generateKotlinCodeWithExternalKey(credentials: [EncryptedCredential]) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten

        package com.example.credentials

        import javax.crypto.Cipher
        import javax.crypto.spec.GCMParameterSpec
        import javax.crypto.spec.SecretKeySpec
        import java.util.Base64
        import java.io.File
        import org.json.JSONObject

        enum class CredentialKey {
        """

        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    \(credential.key),"
        }

        code += "\n}\n\n"

        code += """
        class CredentialException(message: String) : Exception(message)

        object Credentials {
            private data class EncryptedData(
                val data: ByteArray,
                val nonce: ByteArray,
                val tag: ByteArray
            )

            // External key storage
            private var externalKey: SecretKeySpec? = null

            // Encrypted credential data
            private val encryptedData = mapOf(
        """

        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        CredentialKey.\(credential.key) to EncryptedData("
            code += "\n            data = \(formatKotlinByteArray(credential.encryptedData)),"
            code += "\n            nonce = \(formatKotlinByteArray(credential.nonce)),"
            code += "\n            tag = \(formatKotlinByteArray(credential.tag))"
            code += "\n        ),"
        }

        code += "\n    )\n\n"

        code += """
            // Initialize with raw key data
            @JvmStatic
            fun initialize(keyData: ByteArray) {
                externalKey = SecretKeySpec(keyData, "AES")
            }

            // Initialize with base64 encoded key
            @JvmStatic
            fun initialize(base64Key: String) {
                val keyData = Base64.getDecoder().decode(base64Key)
                initialize(keyData)
            }

            // Load key from file (supports JSON or plain text)
            @JvmStatic
            fun loadKey(filePath: String) {
                val file = File(filePath)
                val contents = file.readText().trim()

                // Try to parse as JSON first
                val base64Key = try {
                    val json = JSONObject(contents)
                    json.getString("key")
                } catch (e: Exception) {
                    // If not JSON, use as plain base64 string
                    contents
                }

                initialize(base64Key)
            }

            // Check if initialized
            @JvmStatic
            val isInitialized: Boolean
                get() = externalKey != null

            // Get decrypted credential
            @JvmStatic
            @Throws(CredentialException::class)
            fun get(key: CredentialKey): String {
                val secretKey = externalKey ?: throw CredentialException("Credentials not initialized. Call initialize() or loadKey() first.")
                val encrypted = encryptedData[key] ?: throw CredentialException("Credential not found: $key")

                return try {
                    // Setup cipher for AES-GCM
                    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
                    val gcmSpec = GCMParameterSpec(128, encrypted.nonce)
                    cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec)

                    // Combine ciphertext and tag for decryption
                    val cipherTextWithTag = encrypted.data + encrypted.tag
                    val decrypted = cipher.doFinal(cipherTextWithTag)

                    String(decrypted, Charsets.UTF_8)
                } catch (e: Exception) {
                    throw CredentialException("Failed to decrypt credential: ${e.message}")
                }
            }

            // Optional: Get with caching
            private val cache = mutableMapOf<CredentialKey, String>()

            @JvmStatic
            @Throws(CredentialException::class)
            fun getCached(key: CredentialKey): String {
                cache[key]?.let { return it }

                val decrypted = get(key)
                cache[key] = decrypted
                return decrypted
            }

            // Clear cache when needed
            @JvmStatic
            fun clearCache() {
                cache.clear()
            }
        }
        """

        return code
    }

    public func generateWithExternalKeySource(credentials: [String: String], encryptionKey: Data) throws -> String {
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []

        for (key, plainValue) in credentials {
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }

            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)

            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }

        return generateKotlinCodeWithExternalKeySource(credentials: encryptedCredentials)
    }

    private func generateKotlinCodeWithExternalKeySource(credentials: [EncryptedCredential]) -> String {
        var code = """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten

        package com.example.credentials

        import javax.crypto.Cipher
        import javax.crypto.spec.GCMParameterSpec
        import javax.crypto.spec.SecretKeySpec

        enum class CredentialKey {
        """

        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    \(credential.key),"
        }

        code += "\n}\n\n"

        code += """
        object Credentials {
            private data class EncryptedData(
                val data: ByteArray,
                val nonce: ByteArray,
                val tag: ByteArray
            )

            // Encrypted credential data
            private val encryptedData = mapOf(
        """

        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        CredentialKey.\(credential.key) to EncryptedData("
            code += "\n            data = \(formatKotlinByteArray(credential.encryptedData)),"
            code += "\n            nonce = \(formatKotlinByteArray(credential.nonce)),"
            code += "\n            tag = \(formatKotlinByteArray(credential.tag))"
            code += "\n        ),"
        }

        code += "\n    )\n\n"

        code += """
            // Decrypt using key from CredentialKeyProvider
            @JvmStatic
            fun decrypt(key: CredentialKey): String? {
                val encrypted = encryptedData[key] ?: return null

                return try {
                    // Get key from external source
                    val secretKey = SecretKeySpec(CredentialKeyProvider.key, "AES")

                    // Setup cipher for AES-GCM
                    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
                    val gcmSpec = GCMParameterSpec(128, encrypted.nonce)
                    cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec)

                    // Combine ciphertext and tag for decryption
                    val cipherTextWithTag = encrypted.data + encrypted.tag
                    val decrypted = cipher.doFinal(cipherTextWithTag)

                    String(decrypted, Charsets.UTF_8)
                } catch (e: Exception) {
                    null
                }
            }

            // Optional: Decrypt with caching
            private val cache = mutableMapOf<CredentialKey, String>()

            @JvmStatic
            fun decryptCached(key: CredentialKey): String? {
                cache[key]?.let { return it }

                val decrypted = decrypt(key) ?: return null
                cache[key] = decrypted
                return decrypted
            }

            // Clear cache when needed
            @JvmStatic
            fun clearCache() {
                cache.clear()
            }
        }
        """

        return code
    }

    public func generateKeySource(encryptionKey: Data) throws -> String {
        let base64Key = encryptionKey.base64EncodedString()

        return """
        // Auto-generated by credential-code
        // DO NOT EDIT - This file will be overwritten

        package com.example.credentials

        import java.util.Base64

        object CredentialKeyProvider {
            val key: ByteArray = Base64.getDecoder().decode("\(base64Key)")
        }
        """
    }
}
