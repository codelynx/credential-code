import Foundation
import CryptoKit

public struct PythonCodeGenerator: CodeGenerator {
    public let language = "python"
    public let defaultFileName = "Generated/credentials.py"

    public init() {}

    public func generate(credentials: [String: String], encryptionKey: Data) throws -> String {
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []

        for (key, plainValue) in credentials {
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }

            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)

            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }

        return generatePythonCode(
            credentials: encryptedCredentials,
            runtimeKey: encryptionKey
        )
    }

    private func generatePythonCode(credentials: [EncryptedCredential], runtimeKey: Data) -> String {
        var code = """
        # Auto-generated by credential-code
        # DO NOT EDIT - This file will be overwritten

        from enum import Enum
        from typing import Optional, Dict
        from cryptography.hazmat.primitives.ciphers.aead import AESGCM


        class CredentialKey(Enum):
        """

        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    \(credential.key) = \"\(credential.key)\""
        }

        code += "\n\n\n"

        code += """
        class Credentials:
            # Encrypted credential data as byte arrays
            _encrypted_data = {
        """

        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        CredentialKey.\(credential.key): {"
            code += "\n            'data': \(formatPythonBytes(credential.encryptedData)),"
            code += "\n            'nonce': \(formatPythonBytes(credential.nonce)),"
            code += "\n            'tag': \(formatPythonBytes(credential.tag))"
            code += "\n        },"
        }

        code += "\n    }\n\n"

        let keyComponents = splitIntoComponents(runtimeKey, componentSize: 4)
        code += "    # Runtime decryption key (obfuscated)\n"
        code += "    _key_components = [\n"
        for component in keyComponents {
            code += "        \(formatPythonBytes(component)),\n"
        }
        code += "    ]\n\n"

        code += """
            # Cache for decrypted values
            _cache: Dict[CredentialKey, str] = {}

            @staticmethod
            def decrypt(key: CredentialKey) -> Optional[str]:
                \"\"\"Decrypt a credential by key.\"\"\"
                encrypted = Credentials._encrypted_data.get(key)
                if not encrypted:
                    return None

                try:
                    # Reconstruct the decryption key
                    key_data = b''.join(Credentials._key_components)

                    # Decrypt using AES-GCM
                    aesgcm = AESGCM(key_data)
                    decrypted = aesgcm.decrypt(
                        encrypted['nonce'],
                        encrypted['data'] + encrypted['tag'],
                        None
                    )

                    return decrypted.decode('utf-8')
                except Exception:
                    return None

            @staticmethod
            def decrypt_cached(key: CredentialKey) -> Optional[str]:
                \"\"\"Decrypt a credential with caching.\"\"\"
                if key in Credentials._cache:
                    return Credentials._cache[key]

                decrypted = Credentials.decrypt(key)
                if decrypted:
                    Credentials._cache[key] = decrypted
                return decrypted

            @staticmethod
            def clear_cache() -> None:
                \"\"\"Clear the credential cache.\"\"\"
                Credentials._cache.clear()


        # Convenience function
        def get_credential(key: CredentialKey) -> Optional[str]:
            \"\"\"Get a credential value by key.\"\"\"
            return Credentials.decrypt(key)
        """

        return code
    }

    private func formatPythonBytes(_ data: Data) -> String {
        let bytes = data.map { String(format: "\\x%02x", $0) }

        if data.count <= 16 {
            return "b'" + bytes.joined() + "'"
        }

        var result = "(\n                b'"
        for (index, byte) in bytes.enumerated() {
            if index > 0 && index % 16 == 0 {
                result += "'\n                b'"
            }
            result += byte
        }
        result += "'\n            )"
        return result
    }

    private func splitIntoComponents(_ data: Data, componentSize: Int) -> [Data] {
        var components: [Data] = []
        var offset = 0

        while offset < data.count {
            let remainingBytes = data.count - offset
            let size = min(componentSize, remainingBytes)
            components.append(data.subdata(in: offset..<(offset + size)))
            offset += size
        }

        return components
    }

    public func generateWithExternalKey(credentials: [String: String], encryptionKey: Data) throws -> String {
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []

        for (key, plainValue) in credentials {
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }

            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)

            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }

        return generatePythonCodeWithExternalKey(credentials: encryptedCredentials)
    }

    private func generatePythonCodeWithExternalKey(credentials: [EncryptedCredential]) -> String {
        var code = """
# Auto-generated by credential-code
# DO NOT EDIT - This file will be overwritten

from enum import Enum
from typing import Optional, Dict, Union
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import base64
import json


class CredentialError(Exception):
    \"\"\"Exception raised for credential-related errors.\"\"\"
    pass


class CredentialKey(Enum):
"""

        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    \(credential.key) = \"\(credential.key)\""
        }

        code += "\n\n\n"

        code += """
class Credentials:
    # External key storage
    _external_key: Optional[bytes] = None

    # Encrypted credential data
    _encrypted_data = {
"""

        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        CredentialKey.\(credential.key): {"
            code += "\n            'data': \(formatPythonBytes(credential.encryptedData)),"
            code += "\n            'nonce': \(formatPythonBytes(credential.nonce)),"
            code += "\n            'tag': \(formatPythonBytes(credential.tag))"
            code += "\n        },"
        }

        code += "\n    }\n\n"

        code += """
    # Cache for decrypted values
    _cache: Dict[CredentialKey, str] = {}

    @staticmethod
    def initialize(key_data: bytes) -> None:
        \"\"\"Initialize with raw key data.\"\"\"
        Credentials._external_key = key_data

    @staticmethod
    def initialize_base64(base64_key: str) -> None:
        \"\"\"Initialize with base64 encoded key.\"\"\"
        key_data = base64.b64decode(base64_key)
        Credentials.initialize(key_data)

    @staticmethod
    def load_key(file_path: str) -> None:
        \"\"\"Load key from file (JSON or plain text).\"\"\"
        with open(file_path, 'r') as f:
            contents = f.read().strip()

        # Try JSON first
        try:
            data = json.loads(contents)
            base64_key = data['key']
        except (json.JSONDecodeError, KeyError):
            # If not JSON, use as plain base64 string
            base64_key = contents

        Credentials.initialize_base64(base64_key)

    @staticmethod
    def is_initialized() -> bool:
        \"\"\"Check if credentials are initialized.\"\"\"
        return Credentials._external_key is not None

    @staticmethod
    def get(key: CredentialKey) -> str:
        \"\"\"Get decrypted credential.\"\"\"
        if Credentials._external_key is None:
            raise CredentialError("Credentials not initialized. Call initialize() or load_key() first.")

        encrypted = Credentials._encrypted_data.get(key)
        if not encrypted:
            raise CredentialError(f"Credential not found: {key}")

        try:
            # Decrypt using AES-GCM
            aesgcm = AESGCM(Credentials._external_key)
            decrypted = aesgcm.decrypt(
                encrypted['nonce'],
                encrypted['data'] + encrypted['tag'],
                None
            )

            return decrypted.decode('utf-8')
        except Exception as e:
            raise CredentialError(f"Failed to decrypt credential: {str(e)}")

    @staticmethod
    def get_cached(key: CredentialKey) -> str:
        \"\"\"Get credential with caching.\"\"\"
        if key in Credentials._cache:
            return Credentials._cache[key]

        decrypted = Credentials.get(key)
        Credentials._cache[key] = decrypted
        return decrypted

    @staticmethod
    def clear_cache() -> None:
        \"\"\"Clear the credential cache.\"\"\"
        Credentials._cache.clear()


# Convenience functions
def initialize(key: Union[bytes, str]) -> None:
    \"\"\"Initialize credentials with key.\"\"\"
    if isinstance(key, bytes):
        Credentials.initialize(key)
    else:
        Credentials.initialize_base64(key)

def load_key(file_path: str) -> None:
    \"\"\"Load encryption key from file.\"\"\"
    Credentials.load_key(file_path)

def get_credential(key: CredentialKey) -> str:
    \"\"\"Get a credential value by key.\"\"\"
    return Credentials.get(key)
"""

        return code
    }

    public func generateWithExternalKeySource(credentials: [String: String], encryptionKey: Data) throws -> String {
        let runtimeKey = SymmetricKey(data: encryptionKey)
        var encryptedCredentials: [EncryptedCredential] = []

        for (key, plainValue) in credentials {
            guard let plaintext = plainValue.data(using: .utf8) else {
                throw CredentialError.invalidEncryptedData
            }

            let sealedBox = try AES.GCM.seal(plaintext, using: runtimeKey)

            encryptedCredentials.append(EncryptedCredential(
                key: key,
                encryptedData: sealedBox.ciphertext,
                nonce: sealedBox.nonce.withUnsafeBytes { Data($0) },
                tag: sealedBox.tag
            ))
        }

        return generatePythonCodeWithExternalKeySource(credentials: encryptedCredentials)
    }

    private func generatePythonCodeWithExternalKeySource(credentials: [EncryptedCredential]) -> String {
        var code = """
# Auto-generated by credential-code
# DO NOT EDIT - This file will be overwritten

from enum import Enum
from typing import Optional, Dict
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import credential_key


class CredentialKey(Enum):
"""

        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n    \(credential.key) = \"\(credential.key)\""
        }

        code += "\n\n\n"

        code += """
class Credentials:
    # Encrypted credential data
    _encrypted_data = {
"""

        for credential in credentials.sorted(by: { $0.key < $1.key }) {
            code += "\n        CredentialKey.\(credential.key): {"
            code += "\n            'data': \(formatPythonBytes(credential.encryptedData)),"
            code += "\n            'nonce': \(formatPythonBytes(credential.nonce)),"
            code += "\n            'tag': \(formatPythonBytes(credential.tag))"
            code += "\n        },"
        }

        code += "\n    }\n\n"

        code += """
    # Cache for decrypted values
    _cache: Dict[CredentialKey, str] = {}

    @staticmethod
    def decrypt(key: CredentialKey) -> Optional[str]:
        \"\"\"Decrypt a credential by key.\"\"\"
        encrypted = Credentials._encrypted_data.get(key)
        if not encrypted:
            return None

        try:
            # Get key from external source
            aesgcm = AESGCM(credential_key.key)
            decrypted = aesgcm.decrypt(
                encrypted['nonce'],
                encrypted['data'] + encrypted['tag'],
                None
            )

            return decrypted.decode('utf-8')
        except Exception:
            return None

    @staticmethod
    def decrypt_cached(key: CredentialKey) -> Optional[str]:
        \"\"\"Decrypt a credential with caching.\"\"\"
        if key in Credentials._cache:
            return Credentials._cache[key]

        decrypted = Credentials.decrypt(key)
        if decrypted:
            Credentials._cache[key] = decrypted
        return decrypted

    @staticmethod
    def clear_cache() -> None:
        \"\"\"Clear the credential cache.\"\"\"
        Credentials._cache.clear()


# Convenience function
def get_credential(key: CredentialKey) -> Optional[str]:
    \"\"\"Get a credential value by key.\"\"\"
    return Credentials.decrypt(key)
"""

        return code
    }

    public func generateKeySource(encryptionKey: Data) throws -> String {
        let base64Key = encryptionKey.base64EncodedString()

        return """
        # Auto-generated by credential-code
        # DO NOT EDIT - This file will be overwritten

        import base64

        # Encryption key for credentials
        key = base64.b64decode("\(base64Key)")
        """
    }
}
